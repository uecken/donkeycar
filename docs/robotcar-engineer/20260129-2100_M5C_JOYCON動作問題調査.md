# M5C_JOYCON 動作問題調査レポート

**作成日**: 2026年1月29日
**最終更新**: 2026年1月29日 22:30
**調査対象**: M5C_JOYCON で Donkey Car 操作時のBLE切断とモーター不動作問題
**ステータス**: **調査完了・ファームウェア変更による解決策追加**

---

## 問題概要

### 成功した点
```
INFO:donkeycar.vehicle:Adding part XboxOneJoystickController.
INFO:donkeycar.parts.controller:Opening %s... /dev/input/js0
INFO:donkeycar.parts.controller:Device name: M5StickC JoyPad
```
- XboxOneJoystickControllerが追加された
- M5StickC JoyPadとして認識された
- **サーボ（ステアリング）は動作した**

### 問題1: BLE接続が切断された
```
Exception in thread Thread-5 (update):
OSError: [Errno 19] No such device
  File "controller.py", line 120, in poll
    evbuf = self.jsdev.read(8)
```
ジョイスティックデバイスが途中で切断された

### 問題2: モーター（前後駆動）が動作しない
- サーボは動作するがESC/モーターが動かない
- PWM Throttle createdのログは出ている

---

## 問題1: BLE切断の原因分析

### 1.1 考えられる原因

#### A. BLE接続の不安定性（最も可能性が高い）

M5C_JOYCON（ESP32-BLE-Gamepad）とRaspberry Pi間のBLE接続が不安定になる主な原因：

| 原因 | 詳細 | 対策 |
|------|------|------|
| **ERTM（Enhanced Retransmission Mode）** | Linux BlueZのデフォルト設定がBLE Gamepadと非互換 | `/etc/modprobe.d/bluetooth.conf`でERTM無効化 |
| **電波干渉** | Wi-Fi（2.4GHz）との干渉 | 5GHz Wi-Fiの使用、または距離を離す |
| **バッテリー不足** | M5StickCのバッテリー低下 | 充電状態の確認 |
| **接続タイムアウト** | BlueZのデフォルトタイムアウト | 接続パラメータの調整 |

#### B. Linuxカーネルのジョイスティックドライバ

```
evbuf = self.jsdev.read(8)  # OSError: [Errno 19] No such device
```
`/dev/input/js0` が突然消失したことを示す。これはBLE接続断により発生。

### 1.2 BLE切断の解決策

#### 解決策1: ERTMを無効化（最優先）

```bash
# /etc/modprobe.d/bluetooth.conf を作成
echo "options bluetooth disable_ertm=1" | sudo tee /etc/modprobe.d/bluetooth.conf

# 再起動
sudo reboot

# 確認
cat /sys/module/bluetooth/parameters/disable_ertm
# Y が表示されれば成功
```

**重要**: XboxOneJoystickの公式ドキュメントでもERTM無効化が推奨されている。

#### 解決策2: Bluetooth接続パラメータの最適化

`/etc/bluetooth/main.conf` を編集：

```ini
[General]
Class = 0x000100
ControllerMode = dual
FastConnectable = true
Privacy = device
JustWorksRepairing = always

# 接続維持の設定を追加
IdleTimeout = 0
ReconnectIntervals = 1,2,4,8,16,32,64
ReconnectAttempts = 7

[Policy]
AutoEnable=true
```

#### 解決策3: 自動再接続スクリプト

`/usr/local/bin/reconnect-joypad.sh`:

```bash
#!/bin/bash
# M5C_JOYCON のMACアドレス（実際のアドレスに置換）
MAC_ADDRESS="XX:XX:XX:XX:XX:XX"

while true; do
    if ! hcitool con | grep -q "$MAC_ADDRESS"; then
        echo "$(date): Reconnecting to M5C_JOYCON..."
        bluetoothctl connect "$MAC_ADDRESS"
    fi
    sleep 5
done
```

#### 解決策4: Donkey Carのコントローラー再接続機能

`controller.py` の `update()` メソッドには再接続ロジックがある：

```python
def update(self):
    # wait for joystick to be online
    while self.running and self.js is None and not self.init_js():
        time.sleep(3)
```

ただし、一度接続後に切断された場合の再接続は対応していない。カスタム実装が必要。

### 1.3 BLE接続安定化のための推奨手順

1. **ERTMを無効化**（必須）
2. **Bluetooth設定を最適化**
3. **M5C_JOYCONを再起動**して最新の接続状態にする
4. **ペアリングを再実行**（trust設定も確認）
5. **Wi-Fiを5GHz帯に変更**（可能であれば）

---

## 問題2: モーター（スロットル）不動作の原因分析

### 2.1 XboxOneJoystick の軸マッピング

`donkeycar/parts/controller.py` より XboxOneJoystick の軸マッピング：

```python
class XboxOneJoystick(Joystick):
    def __init__(self, *args, **kwargs):
        super(XboxOneJoystick, self).__init__(*args, **kwargs)

        self.axis_names = {
            0x00 : 'left_stick_horz',      # ステアリング用
            0x01 : 'left_stick_vert',
            0x05 : 'right_stick_vert',     # スロットル用 ← 重要
            0x02 : 'right_stick_horz',
            0x0a : 'left_trigger',
            0x09 : 'right_trigger',
            0x10 : 'dpad_horiz',
            0x11 : 'dpad_vert'
        }
```

**重要**: スロットルは `right_stick_vert`（軸コード `0x05`）に割り当てられている。

### 2.2 M5C_JOYCON の軸マッピング

M5C_JOYCONは2軸のみを持つシンプルなGamepad：

| 軸 | コード（予想） | 用途 |
|----|---------------|------|
| X軸 | `0x00` | ステアリング |
| Y軸 | `0x01` | スロットル（のはず） |

### 2.3 問題の原因

**XboxOneJoystick は Y軸（スロットル）を `0x05` として期待しているが、M5C_JOYCON は `0x01` として送信している可能性が高い。**

| 軸 | Xbox期待値 | M5C_JOYCON実際値 | マッピング結果 |
|----|-----------|------------------|---------------|
| X軸（ステアリング） | `0x00` → `left_stick_horz` | `0x00` | **動作する** |
| Y軸（スロットル） | `0x05` → `right_stick_vert` | `0x01` → `left_stick_vert` | **動作しない** |

XboxOneJoystickControllerでは `left_stick_vert`（`0x01`）はスロットルに割り当てられていない：

```python
class XboxOneJoystickController(JoystickController):
    def init_trigger_maps(self):
        self.axis_trigger_map = {
            'left_stick_horz': self.set_steering,  # 0x00 → ステアリング
            'right_stick_vert': self.set_throttle, # 0x05 → スロットル
            # left_stick_vert (0x01) は使用されていない！
        }
```

### 2.4 スロットル不動作の解決策

#### 解決策1: XboxOneSwappedJoystickController を使用

`controller.py` には `XboxOneSwappedJoystickController` があり、スティックの割り当てを入れ替える：

```python
class XboxOneSwappedJoystickController(XboxOneJoystickController):
    def init_trigger_maps(self):
        super(XboxOneSwappedJoystickController, self).init_trigger_maps()

        # make the actual swap of the sticks
        self.set_axis_trigger('right_stick_horz', self.set_steering)
        self.set_axis_trigger('left_stick_vert', self.set_throttle)  # ← これが必要

        # unmap default assignments
        self.set_axis_trigger('left_stick_horz', self.do_nothing)
        self.set_axis_trigger('right_stick_vert', self.do_nothing)
```

**myconfig.py での設定**:

```python
CONTROLLER_TYPE = "xboxswapped"
```

#### 解決策2: カスタムコントローラーの作成（推奨）

`~/mycar/my_joystick.py` を作成：

```python
from donkeycar.parts.controller import Joystick, JoystickController


class M5CJoycon(Joystick):
    """
    M5StickC JoyPad (M5C_JOYCON) のマッピング定義
    2軸のみの単純なGamepad
    """
    def __init__(self, *args, **kwargs):
        super(M5CJoycon, self).__init__(*args, **kwargs)

        # M5C_JOYCON の実際の軸マッピング
        self.axis_names = {
            0x00: 'x_axis',      # X軸（ステアリング）
            0x01: 'y_axis',      # Y軸（スロットル）
        }

        # ボタンマッピング
        self.button_names = {
            0x130: 'btn_a',      # BUTTON_1 (BtnA or JoyStick button)
        }


class M5CJoyconController(JoystickController):
    """
    M5C_JOYCON 用コントローラー
    """
    def __init__(self, *args, **kwargs):
        super(M5CJoyconController, self).__init__(*args, **kwargs)

    def init_js(self):
        try:
            self.js = M5CJoycon(self.dev_fn)
            if not self.js.init():
                self.js = None
        except FileNotFoundError:
            print(f"{self.dev_fn} not found.")
            self.js = None
        return self.js is not None

    def init_trigger_maps(self):
        """
        ボタン・軸のアクション割り当て
        """
        # ボタン押下時のアクション
        self.button_down_trigger_map = {
            'btn_a': self.toggle_mode,
        }

        # ボタン離した時のアクション
        self.button_up_trigger_map = {}

        # 軸のアクション - X軸がステアリング、Y軸がスロットル
        self.axis_trigger_map = {
            'x_axis': self.set_steering,
            'y_axis': self.set_throttle,
        }
```

**使用方法**:

1. `my_joystick.py` を `~/mycar/` に配置
2. `myconfig.py` で `CONTROLLER_TYPE = "custom"` に設定
3. `manage.py` でカスタムコントローラーをインポート（必要に応じて修正）

#### 解決策3: jstest で軸コードを確認してから決定

```bash
# Raspberry Pi で実行
jstest /dev/input/js0
```

出力例：
```
Axes:  0:     0  1:     0
```

- 軸0がX軸（水平方向）
- 軸1がY軸（垂直方向）

XboxOneJoystickでは軸5（`0x05`）がスロットルに割り当てられているが、M5C_JOYCONでは軸1しかないため、軸マッピングが合わない。

---

## 問題2補足: ESCのPWM設定確認

### 現在の設定 (myconfig.py)

```python
PWM_STEERING_THROTTLE = {
    "PWM_THROTTLE_PIN": "PCA9685.1:40.0",   # ESC on channel 0
    "PWM_THROTTLE_SCALE": 1.0,
    "PWM_THROTTLE_INVERTED": False,

    # スロットル値
    "THROTTLE_FORWARD_PWM": 324,            # 1370us
    "THROTTLE_STOPPED_PWM": 307,            # 1500us
    "THROTTLE_REVERSE_PWM": 287,            # 1610us
}
```

### 値の検証

| 設定 | PWM値 | パルス幅（60Hz基準） | 備考 |
|------|-------|---------------------|------|
| FORWARD | 324 | ~1.32ms | やや短い |
| STOPPED | 307 | ~1.25ms | **通常1.5msが標準** |
| REVERSE | 287 | ~1.17ms | 短すぎる可能性 |

**注意**: コメントには `1370us`, `1500us`, `1610us` とあるが、PWM値との対応が不明確。Donkey Car のデフォルト周波数は60Hzで、計算式は異なる可能性がある。

### PWM値の再計算（60Hz基準）

60Hz（周期16.67ms）での12ビットPWM値：

```
パルス幅(ms) = PWM値 / 4096 * 16.67ms
```

| 目標パルス幅 | 計算式 | PWM値 |
|-------------|--------|-------|
| 1.0ms（最小） | 1.0 / 16.67 * 4096 | 246 |
| 1.5ms（ニュートラル） | 1.5 / 16.67 * 4096 | 368 |
| 2.0ms（最大） | 2.0 / 16.67 * 4096 | 491 |

**推奨設定**:

```python
PWM_STEERING_THROTTLE = {
    "THROTTLE_FORWARD_PWM": 450,    # 前進（~1.83ms）
    "THROTTLE_STOPPED_PWM": 368,    # 停止（~1.5ms）
    "THROTTLE_REVERSE_PWM": 280,    # 後退（~1.14ms）
}
```

ただし、ESCのアーム状態やキャリブレーションが重要。

### ESCアーム確認

ESCが正しくアームされていない場合、スロットル入力を受け付けない。

**確認事項**:
1. ESCの電源を入れたときにビープ音が鳴るか
2. スロットルがニュートラル（1.5ms付近）から始まっているか
3. PWM周波数が50Hz〜60Hzの範囲内か

**ESC初期化シーケンス（PWMThrottleクラスより）**:

```python
# ESCキャリブレーション
self.controller.set_pulse(self.max_pulse)  # 最大値
time.sleep(0.01)
self.controller.set_pulse(self.min_pulse)  # 最小値
time.sleep(0.01)
self.controller.set_pulse(self.zero_pulse) # ニュートラル
time.sleep(1)
```

---

## 解決策まとめ

### 問題1（BLE切断）の解決策

| 優先度 | 対策 | 実施方法 |
|--------|------|----------|
| **1** | ERTM無効化 | `echo "options bluetooth disable_ertm=1" \| sudo tee /etc/modprobe.d/bluetooth.conf && sudo reboot` |
| **2** | Bluetooth設定最適化 | `/etc/bluetooth/main.conf` 編集 |
| **3** | 再ペアリング | `bluetoothctl` で pair/trust/connect |
| 4 | 自動再接続スクリプト | systemdサービスとして登録 |

### 問題2（モーター不動作）の解決策

| 優先度 | 対策 | 実施方法 |
|--------|------|----------|
| **1** | jstest で軸マッピング確認 | `jstest /dev/input/js0` |
| **2** | カスタムコントローラー作成 | `my_joystick.py` 作成、`CONTROLLER_TYPE = "custom"` |
| 3 | xboxswapped 使用 | `CONTROLLER_TYPE = "xboxswapped"` |
| 4 | PWM値の再キャリブレーション | `donkey calibrate --channel=0` |

---

## 診断コマンド集

### BLE接続診断

```bash
# Bluetooth状態確認
sudo systemctl status bluetooth

# ERTM設定確認
cat /sys/module/bluetooth/parameters/disable_ertm

# 接続状態確認
bluetoothctl info XX:XX:XX:XX:XX:XX

# ジョイスティックデバイス確認
ls -la /dev/input/js*

# リアルタイム接続監視
watch -n 1 'hcitool con'
```

### ジョイスティック診断

```bash
# 軸・ボタン確認
jstest /dev/input/js0

# 詳細イベント確認
sudo evtest /dev/input/event*

# Donkey Car のジョイスティック作成ウィザード
donkey createjs
```

### PWM/ESC診断

```bash
# I2C接続確認
i2cdetect -y 1

# PWMキャリブレーション
donkey calibrate --channel=0
donkey calibrate --channel=1
```

---

## 次のアクション

1. **Raspberry Pi でERTM無効化を実施**
2. **jstest で M5C_JOYCON の軸マッピングを確認**
3. **確認結果に基づきカスタムコントローラーを作成**
4. **ESCのPWM値を再キャリブレーション**

---

## 関連資料

| 資料名 | パス |
|--------|------|
| M5C_JOYCON統合ガイド | `docs/robotcar-engineer/20260129-1600_M5C_JOYCON_DonkeyCar統合ガイド.md` |
| Joystick認識問題調査 | `docs/robotcar-engineer/20260129-1200_Joystick認識問題調査.md` |
| PWM動作調査レポート | `docs/robotcar-engineer/20260128-1730_PWM動作調査レポート.md` |
| Donkey Car起動ガイド | `docs/robotcar-engineer/20260129-1830_DonkeyCar起動ガイド.md` |

---

## 軸コードの違いについて（技術解説）

### Linux Joystick API の軸コード体系

Linux カーネルは、ゲームパッドやジョイスティックの軸を**ABS（Absolute）コード**で管理する。これは `linux/input-event-codes.h` で定義されている。

#### 主要な軸コード一覧

| 軸コード | 16進値 | 10進値 | 標準的な意味 |
|---------|--------|--------|-------------|
| `ABS_X` | 0x00 | 0 | 左スティック X軸（水平） |
| `ABS_Y` | 0x01 | 1 | 左スティック Y軸（垂直） |
| `ABS_Z` | 0x02 | 2 | Z軸（トリガーまたは追加軸） |
| `ABS_RX` | 0x03 | 3 | 右スティック X軸（水平） |
| `ABS_RY` | 0x04 | 4 | 右スティック Y軸（垂直） |
| `ABS_RZ` | 0x05 | 5 | 回転Z軸（右トリガーまたは追加軸） |
| `ABS_THROTTLE` | 0x06 | 6 | スロットル |
| `ABS_RUDDER` | 0x07 | 7 | ラダー |
| `ABS_HAT0X` | 0x10 | 16 | D-Pad X軸（水平） |
| `ABS_HAT0Y` | 0x11 | 17 | D-Pad Y軸（垂直） |

#### Linux Gamepad Specification（カーネル公式ドキュメント）より

```
左アナログスティック: ABS_X (0x00), ABS_Y (0x01)
右アナログスティック: ABS_RX (0x03), ABS_RY (0x04)
```

ただし、これは**推奨**であり、すべてのデバイスがこの規格に従うわけではない。

---

### Xbox コントローラーの軸配置

`donkeycar/parts/controller.py` の `XboxOneJoystick` クラスを確認すると、以下のマッピングが定義されている：

```python
class XboxOneJoystick(Joystick):
    def __init__(self, *args, **kwargs):
        self.axis_names = {
            0x00 : 'left_stick_horz',   # 左スティック水平
            0x01 : 'left_stick_vert',   # 左スティック垂直
            0x05 : 'right_stick_vert',  # 右スティック垂直 ← スロットル用
            0x02 : 'right_stick_horz',  # 右スティック水平
            0x0a : 'left_trigger',
            0x09 : 'right_trigger',
            0x10 : 'dpad_horiz',
            0x11 : 'dpad_vert'
        }
```

#### Xbox コントローラーの軸レイアウト

```
┌─────────────────────────────────────────────────────────┐
│                    Xbox One Controller                   │
│                                                          │
│    左スティック                    右スティック           │
│    ┌───────┐                      ┌───────┐             │
│    │   ↑   │                      │   ↑   │             │
│    │←  ●  →│ 0x00(X), 0x01(Y)    │←  ●  →│ 0x02(X), 0x05(Y)
│    │   ↓   │                      │   ↓   │             │
│    └───────┘                      └───────┘             │
│                                                          │
│    LT: 0x0a        [Xbox]          RT: 0x09             │
│                                                          │
│              D-Pad: 0x10(X), 0x11(Y)                    │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

**注意点**:
- **右スティックのY軸が `0x05` (`ABS_RZ`)**となっている
- これは Linux の標準規格（`0x04` = `ABS_RY`）とは異なる
- Xbox ドライバーの実装による独自のマッピング

---

### M5C_JOYCON の軸配置

M5C_JOYCON は ESP32-BLE-Gamepad ライブラリを使用してBLE HID Gamepadとして動作する。

#### ESP32-BLE-Gamepad の軸定義

ファームウェア（`main.cpp`）の設定：

```cpp
BleGamepadConfiguration config;
config.setWhichAxes(true, true, false, false, false, false, false, false);
//                   X     Y     Z    rZ    rX    rY   slider1 slider2

// 軸の値設定
bleGamepad.setX(x);  // X軸（ステアリング）
bleGamepad.setY(y);  // Y軸（スロットル）
```

`setWhichAxes(true, true, false, ...)` により、**X軸とY軸のみ**を有効化している。

#### HID レポートでの軸順序

ESP32-BLE-Gamepad ライブラリでは、HID レポートは以下の順序で軸を報告する：

```
軸の順序: X → Y → Z → rZ → rX → rY → slider1 → slider2
```

M5C_JOYCON は X と Y のみ有効なので、Linux カーネルからは以下のように見える：

| 軸インデックス | HID Usage | Linux ABS コード | 用途 |
|--------------|-----------|-----------------|------|
| 0 | X | `ABS_X` (0x00) | ステアリング |
| 1 | Y | `ABS_Y` (0x01) | スロットル |

#### M5C_JOYCON の軸レイアウト

```
┌─────────────────────────────────────────────────────────┐
│               M5C_JOYCON (M5StickC + JoyStick)          │
│                                                          │
│                    単一スティック                        │
│                    ┌───────┐                             │
│                    │   ↑   │                             │
│                    │←  ●  →│  0x00(X), 0x01(Y)          │
│                    │   ↓   │                             │
│                    └───────┘                             │
│                                                          │
│           BtnA (M5StickC本体ボタン): BUTTON_1           │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

---

### なぜ違いが生じるのか

#### 根本原因: HID Usage ID とドライバー解釈の違い

1. **HID (Human Interface Device) 仕様**
   - USB HID 規格では、ゲームパッドの軸は「Generic Desktop Page (0x01)」の Usage ID で定義される
   - 標準的な Usage ID:
     - X軸: 0x30
     - Y軸: 0x31
     - Z軸: 0x32
     - Rx軸: 0x33
     - Ry軸: 0x34
     - Rz軸: 0x35

2. **カーネルドライバーの軸マッピング**
   - Linux カーネルのHIDドライバーは、HID Usage ID を ABS コードに変換する
   - この変換はドライバーごとに異なる場合がある

3. **Xbox コントローラー固有の事情**
   - Xbox コントローラーは Microsoft 独自のHIDレポート構造を持つ
   - 右スティックY軸が `ABS_RZ` (0x05) として報告されるのは、Xboxドライバーの実装による
   - これは一般的なGamepadとは異なるマッピング

4. **ESP32-BLE-Gamepad の挙動**
   - 標準的な HID Gamepad レポートを生成
   - X軸 → `ABS_X` (0x00)
   - Y軸 → `ABS_Y` (0x01)
   - 追加の軸がある場合のみ Z, rZ, rX, rY が順次割り当てられる

#### 図解: 軸コードの違い

```
┌────────────────────────────────────────────────────────────────────┐
│                     軸コードマッピングの比較                        │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  【Xbox One コントローラー】                                        │
│                                                                     │
│   左スティック        右スティック         トリガー                 │
│   ┌─────────┐        ┌─────────┐        LT    RT                   │
│   │ X: 0x00 │        │ X: 0x02 │       0x0a  0x09                  │
│   │ Y: 0x01 │        │ Y: 0x05 │  ← 特殊（ABS_RZ）                  │
│   └─────────┘        └─────────┘                                    │
│                                                                     │
│   スロットル = 右スティックY軸 = 0x05 (right_stick_vert)           │
│                                                                     │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  【M5C_JOYCON (ESP32-BLE-Gamepad)】                                │
│                                                                     │
│   単一スティック（2軸のみ）                                         │
│   ┌─────────┐                                                       │
│   │ X: 0x00 │  ← 標準的な HID X軸                                   │
│   │ Y: 0x01 │  ← 標準的な HID Y軸                                   │
│   └─────────┘                                                       │
│                                                                     │
│   スロットル = Y軸 = 0x01 (ABS_Y)                                   │
│                                                                     │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  【問題】XboxOneJoystickController でM5C_JOYCONを使用する場合       │
│                                                                     │
│   期待される軸:                                                     │
│     ステアリング: 'left_stick_horz' (0x00) → M5C 0x00 ✓ 一致       │
│     スロットル:   'right_stick_vert' (0x05) → M5C には存在しない ✗  │
│                                                                     │
│   実際の M5C_JOYCON:                                                │
│     0x00: X軸 → 'left_stick_horz' としてマッピング → ステアリング動作│
│     0x01: Y軸 → 'left_stick_vert' としてマッピング → 未使用（無視）│
│                                                                     │
│   結果: ステアリングは動作するが、スロットルは動作しない            │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
```

---

### 解決策の技術的根拠

#### 方法1: カスタムコントローラー作成

M5C_JOYCON専用のマッピング定義を作成し、Y軸（0x01）をスロットルに割り当てる。

```python
class M5CJoycon(Joystick):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.axis_names = {
            0x00: 'x_axis',   # HID X → ステアリング
            0x01: 'y_axis',   # HID Y → スロットル
        }

class M5CJoyconController(JoystickController):
    def init_trigger_maps(self):
        self.axis_trigger_map = {
            'x_axis': self.set_steering,
            'y_axis': self.set_throttle,  # 0x01 をスロットルに
        }
```

#### 方法2: XboxOneSwappedJoystickController の利用

このコントローラーは `left_stick_vert` (0x01) をスロットルに割り当てているため、M5C_JOYCON と互換性がある。

```python
# controller.py より
class XboxOneSwappedJoystickController(XboxOneJoystickController):
    def init_trigger_maps(self):
        super().init_trigger_maps()
        self.set_axis_trigger('left_stick_vert', self.set_throttle)  # 0x01 → スロットル
```

---

### 参考資料

| 資料 | URL |
|------|-----|
| Linux Gamepad Specification | https://docs.kernel.org/input/gamepad.html |
| Linux Joystick API | https://docs.kernel.org/input/joydev/joystick-api.html |
| ESP32-BLE-Gamepad GitHub | https://github.com/lemmingDev/ESP32-BLE-Gamepad |
| USB HID Usage Tables | https://usb.org/sites/default/files/hut1_4.pdf |

---

## jstest による実機テスト結果（2026-01-29 21:45）

### jstestの出力

```
Joystick (M5StickC JoyPad) has 2 axes (X, Y)
and 1 buttons (BtnA).
Axes:  0: 20158  1: -9362 Buttons:  0:off
```

**重要な発見**:
- **Axis 0 (0x00)** と **Axis 1 (0x01)** は両方とも正常に動作している
- ボタンは1つ（BtnA）

### 問題の本質（確定）

| M5C_JOYCON 軸 | XboxOneJoystickController での扱い | 結果 |
|--------------|-----------------------------------|------|
| Axis 0 (0x00) | `left_stick_horz` → `set_steering` | **動作** |
| Axis 1 (0x01) | `left_stick_vert` → **何にも割り当てなし** | **動作しない** |

XboxOneJoystickController は以下のようにマッピングしている：
```python
self.axis_trigger_map = {
    'left_stick_horz': self.set_steering,     # axis 0x00 → ステアリング
    'right_stick_vert': self.set_throttle,     # axis 0x05 → スロットル
}
```

M5C_JOYCON の axis 0x01 (`left_stick_vert`) は **どのアクションにもマッピングされていない**。

---

## 解決策の優先順位（更新）

### 最も簡単な解決策: `CONTROLLER_TYPE = "rc3"` を試す

`RC3ChanJoystick` は axis 0x00 をステアリング、axis 0x01 をスロットルにマッピングしている：

```python
class RC3ChanJoystick(Joystick):
    self.axis_names = {
        0x1 : 'Throttle',    # axis 0x01 → スロットル
        0x0 : 'Steering',    # axis 0x00 → ステアリング
    }
```

**myconfig.py での設定**:
```python
CONTROLLER_TYPE = "rc3"
```

**注意**: RC3ChanJoystickController のボタンマッピングが M5C_JOYCON と異なる可能性がある。

### 解決策2: `CONTROLLER_TYPE = "xboxswapped"` を使用

`XboxOneSwappedJoystickController` は `left_stick_vert` (axis 0x01) をスロットルにマッピングしている：

```python
class XboxOneSwappedJoystickController(XboxOneJoystickController):
    def init_trigger_maps(self):
        super().init_trigger_maps()
        self.set_axis_trigger('left_stick_vert', self.set_throttle)  # axis 0x01 → スロットル
        self.set_axis_trigger('left_stick_horz', self.do_nothing)    # axis 0x00 → 無効
```

**問題**: `left_stick_horz` (axis 0x00) が `do_nothing` に設定されるため、ステアリングも動作しなくなる可能性がある。

**myconfig.py での設定**:
```python
CONTROLLER_TYPE = "xboxswapped"
```

### 解決策3: カスタムコントローラーの作成（確実な方法）

M5C_JOYCON専用のコントローラーを作成する（既存のドキュメントに記載済み）。

---

## 推奨テスト手順

1. **まず `rc3` を試す**
   ```python
   # myconfig.py
   CONTROLLER_TYPE = "rc3"
   ```

2. **動作しない場合は `xboxswapped` を試す**
   ```python
   # myconfig.py
   CONTROLLER_TYPE = "xboxswapped"
   ```

3. **両方とも問題がある場合はカスタムコントローラーを作成**

---

## 各コントローラータイプの axis_trigger_map 比較

| CONTROLLER_TYPE | axis 0x00 の用途 | axis 0x01 の用途 | M5C_JOYCON互換性 |
|-----------------|------------------|------------------|------------------|
| `xbox` | ステアリング | なし | 部分的（スロットル不可） |
| `xboxswapped` | なし | スロットル | 部分的（ステアリング不可？要検証） |
| `rc3` | ステアリング | スロットル | **完全互換（推奨）** |
| `ps3` | ステアリング | なし | 部分的 |
| `ps4` | ステアリング | なし | 部分的 |
| `F710` | ステアリング | なし | 部分的 |

---

---

## ESP32-BLE-Gamepad ファームウェア変更による解決策調査（2026-01-29 22:30）

### 調査課題

M5C_JOYCONのファームウェアを変更して、以下の両方の軸を同時に送信できるか：
- `0x01` (left_stick_vert / ABS_Y)
- `0x05` (right_stick_vert / ABS_RZ)

これにより、XboxOneJoystickControllerでもM5C_JOYCONを使用できるようになる可能性がある。

### 調査結果: **技術的に可能**

#### 1. ESP32-BLE-Gamepad の軸設定

`main.cpp` での現在の設定：

```cpp
config.setWhichAxes(true, true, false, false, false, false, false, false);
//                   X     Y     Z    rX    rY    rZ   slider1 slider2
```

`setWhichAxes()` の引数順序：
| 引数位置 | 軸名 | HID Usage ID | Linux ABS コード |
|---------|------|--------------|------------------|
| 1 | X | 0x30 | ABS_X (0x00) |
| 2 | Y | 0x31 | ABS_Y (0x01) |
| 3 | Z | 0x32 | ABS_Z (0x02) |
| 4 | rX | 0x33 | ABS_RX (0x03) |
| 5 | rY | 0x34 | ABS_RY (0x04) |
| 6 | rZ | 0x35 | ABS_RZ (0x05) |
| 7 | slider1 | - | - |
| 8 | slider2 | - | - |

#### 2. HID Usage ID から Linux ABS コードへの変換

Linux カーネルの `hid-input.c` では、HID Usage ID の下位4ビットを使って ABS コードにマッピングする：

```c
// Linux カーネル hid-input.c より
map_abs_clear(usage->hid & 0xf);
```

| HID Usage ID | & 0xf | Linux ABS |
|--------------|-------|-----------|
| 0x30 (X) | 0x0 | ABS_X |
| 0x31 (Y) | 0x1 | ABS_Y |
| 0x32 (Z) | 0x2 | ABS_Z |
| 0x33 (rX) | 0x3 | ABS_RX |
| 0x34 (rY) | 0x4 | ABS_RY |
| 0x35 (rZ) | 0x5 | ABS_RZ |

#### 3. XboxOneJoystickController が期待する軸

```python
# donkeycar/parts/controller.py
class XboxOneJoystick(Joystick):
    self.axis_names = {
        0x00 : 'left_stick_horz',   # ステアリング用
        0x01 : 'left_stick_vert',
        0x05 : 'right_stick_vert',  # スロットル用
        0x02 : 'right_stick_horz',
    }

class XboxOneJoystickController(JoystickController):
    self.axis_trigger_map = {
        'left_stick_horz': self.set_steering,   # ABS_X (0x00)
        'right_stick_vert': self.set_throttle,  # ABS_RZ (0x05)
    }
```

### 4. 必要なファームウェア変更

#### 変更点1: `setWhichAxes()` で rZ 軸を有効化

```cpp
// 変更前
config.setWhichAxes(true, true, false, false, false, false, false, false);
//                   X     Y     Z    rX    rY    rZ   slider1 slider2

// 変更後 - X と rZ を有効化
config.setWhichAxes(true, false, false, false, false, true, false, false);
//                   X     Y     Z    rX    rY    rZ   slider1 slider2
```

または、X, Y, rZ すべてを有効化して、スティックのY値を両方の軸に送信：

```cpp
// X, Y, rZ を有効化
config.setWhichAxes(true, true, false, false, false, true, false, false);
```

#### 変更点2: 軸の値を設定

```cpp
// 変更前
bleGamepad.setX(x);
bleGamepad.setY(y);

// 変更後 - Y値をrZにも設定
bleGamepad.setX(x);     // ステアリング → ABS_X (0x00)
bleGamepad.setY(y);     // Y軸 → ABS_Y (0x01) ※オプション
bleGamepad.setRZ(y);    // スロットル → ABS_RZ (0x05)
```

### 5. 具体的な `main.cpp` 変更案

#### 方法A: X + rZ のみ（最小構成）

```cpp
// setup() 関数内
BleGamepadConfiguration config;
config.setAutoReport(false);
config.setControllerType(CONTROLLER_TYPE_GAMEPAD);
config.setButtonCount(1);
config.setHatSwitchCount(0);

// X軸（ステアリング）とrZ軸（スロットル）のみ有効化
config.setWhichAxes(true, false, false, false, false, true, false, false);
//                   X     Y     Z    rX    rY    rZ   slider1 slider2

config.setAxesMin(0);
config.setAxesMax(32767);
bleGamepad.begin(&config);

// ---

// loop() 関数内
if (bleGamepad.isConnected()) {
    if (changed) {
        bleGamepad.setX(x);     // ステアリング → ABS_X (0x00)
        bleGamepad.setRZ(y);    // スロットル → ABS_RZ (0x05)

        // ボタン処理は変更なし
        if (button && !prevButton) {
            bleGamepad.press(BUTTON_1);
        } else if (!button && prevButton) {
            bleGamepad.release(BUTTON_1);
        }

        bleGamepad.sendReport();
    }
}
```

#### 方法B: X + Y + rZ（互換性重視）

```cpp
// setup() 関数内
// X, Y, rZ すべて有効化（rc3コントローラーとも互換）
config.setWhichAxes(true, true, false, false, false, true, false, false);

// ---

// loop() 関数内
bleGamepad.setX(x);     // ステアリング → ABS_X (0x00) → left_stick_horz
bleGamepad.setY(y);     // スロットル → ABS_Y (0x01) → left_stick_vert
bleGamepad.setRZ(y);    // スロットル → ABS_RZ (0x05) → right_stick_vert (Xbox互換)
```

この方法では、Y軸の値が ABS_Y (0x01) と ABS_RZ (0x05) の両方に送信される。
これにより以下のコントローラータイプすべてで動作する：
- `CONTROLLER_TYPE = "xbox"` (ABS_X + ABS_RZ)
- `CONTROLLER_TYPE = "rc3"` (ABS_X + ABS_Y)
- `CONTROLLER_TYPE = "xboxswapped"` (ABS_Y がスロットル)

### 6. 結論

| 項目 | 回答 |
|------|------|
| **技術的に可能か** | **はい** |
| **同時送信可能か** | **はい** - Y値を `setY()` と `setRZ()` の両方で送信できる |
| **推奨実装方法** | 方法B（X + Y + rZ）- 最大互換性 |
| **変更箇所** | `main.cpp` の `setup()` と `loop()` の2箇所 |
| **副作用** | HIDレポートサイズがわずかに増加（2バイト追加） |

### 7. テスト計画

1. **ファームウェア変更後のビルド・アップロード**
   ```bash
   cd picopico_racers/M5C_JOYCON
   pio run -t upload
   ```

2. **Raspberry Pi での認識確認**
   ```bash
   jstest /dev/input/js0
   # 期待される出力: Axes: 0:xxx 1:xxx 2:xxx (X, Y, rZ)
   # または: Axes: 0:xxx 5:xxx (X, rZ のみ)
   ```

3. **Donkey Car での動作確認**
   ```python
   # myconfig.py
   CONTROLLER_TYPE = "xbox"
   ```

### 8. 参考資料

| 資料 | URL |
|------|-----|
| ESP32-BLE-Gamepad GitHub | https://github.com/lemmingDev/ESP32-BLE-Gamepad |
| ESP32-BLE-Gamepad Configuration | https://github.com/lemmingDev/ESP32-BLE-Gamepad/blob/master/BleGamepadConfiguration.cpp |
| Linux HID Input Driver | https://github.com/torvalds/linux/blob/master/drivers/hid/hid-input.c |
| Linux Gamepad Specification | https://docs.kernel.org/input/gamepad.html |
| USB HID Usage Tables | http://www.freebsddiary.org/APC/usb_hid_usages.php |

---

## ステアリング軸の反転設定

### 課題

ジョイスティックの左右（ステアリング）のみを反転させたい場合がある。

### 解決策: `JOYSTICK_STEERING_SCALE` を使用

`myconfig.py` で以下の設定を行うと、**ステアリング軸のみ反転**できる：

```python
# myconfig.py

# ステアリング反転（-1.0 で反転）
JOYSTICK_STEERING_SCALE = -1.0
```

### 仕組み

`donkeycar/parts/controller.py` の `JoystickController` クラス内で、ステアリング値に `steering_scale` が乗算される：

```python
# controller.py line 1017
def set_steering(self, axis_val):
    self.angle = self.steering_scale * axis_val
```

| 設定値 | 効果 |
|--------|------|
| `1.0` | 通常動作（反転なし） |
| `-1.0` | **左右反転** |
| `0.5` | 感度を半分に（反転なし） |
| `-0.5` | 感度を半分に + 反転 |

### 使用例

```python
# myconfig.py

# ジョイスティック設定
USE_JOYSTICK_AS_DEFAULT = True
CONTROLLER_TYPE = "rc3"
JOYSTICK_DEVICE_FILE = "/dev/input/js0"

# ステアリング反転
JOYSTICK_STEERING_SCALE = -1.0    # 左右反転

# スロットル設定（反転が必要な場合）
JOYSTICK_THROTTLE_DIR = -1.0      # 前後反転
JOYSTICK_MAX_THROTTLE = 1.0
```

### 注意事項

- **スロットル（前後）の反転**は別設定 `JOYSTICK_THROTTLE_DIR` で行う
- `JOYSTICK_STEERING_SCALE` は感度調整にも使用可能（0.5 で半分の感度）
- 設定変更後は Donkey Car の再起動が必要

### 設定確認コマンド

```bash
# Raspberry Pi で実行
cd ~/mycar
python3 -c "
import donkeycar as dk
cfg = dk.load_config()
print('JOYSTICK_STEERING_SCALE:', cfg.JOYSTICK_STEERING_SCALE)
print('JOYSTICK_THROTTLE_DIR:', cfg.JOYSTICK_THROTTLE_DIR)
"
```

---

## ジョイスティック感度・速度調整

### 利用可能な設定項目

| 設定 | 用途 | デフォルト | 範囲 |
|------|------|-----------|------|
| `JOYSTICK_STEERING_SCALE` | ステアリング感度・反転 | `1.0` | -1.0 〜 1.0 |
| `JOYSTICK_MAX_THROTTLE` | **最大スロットル制限** | `0.5` | 0.0 〜 1.0 |
| `JOYSTICK_THROTTLE_DIR` | スロットル方向反転 | `-1.0` | -1.0 or 1.0 |
| `JOYSTICK_DEADZONE` | デッドゾーン | `0.01` | 0.0 〜 0.5 |

### 仕組み

`donkeycar/parts/controller.py` での計算式：

```python
# ステアリング（line 1017）
self.angle = self.steering_scale * axis_val

# スロットル（line 1024）
self.throttle = self.throttle_dir * axis_val * self.throttle_scale
```

| 計算要素 | 設定項目 | 効果 |
|---------|---------|------|
| `steering_scale` | `JOYSTICK_STEERING_SCALE` | ステアリング感度・反転 |
| `throttle_scale` | `JOYSTICK_MAX_THROTTLE` | **最大速度制限** |
| `throttle_dir` | `JOYSTICK_THROTTLE_DIR` | 前後方向反転 |

### 設定例

```python
# myconfig.py

# === ジョイスティック基本設定 ===
USE_JOYSTICK_AS_DEFAULT = True
CONTROLLER_TYPE = "rc3"
JOYSTICK_DEVICE_FILE = "/dev/input/js0"

# === ステアリング調整 ===
JOYSTICK_STEERING_SCALE = 1.0     # 1.0=通常, 0.5=感度半分, -1.0=反転

# === スロットル（速度）調整 ===
JOYSTICK_MAX_THROTTLE = 0.5       # ★最大速度を50%に制限（安全のため推奨）
JOYSTICK_THROTTLE_DIR = -1.0      # -1.0=通常, 1.0=前後反転

# === デッドゾーン ===
JOYSTICK_DEADZONE = 0.01          # スティック中央付近の不感帯
```

### 設定値の効果

#### ステアリング（`JOYSTICK_STEERING_SCALE`）

| 設定値 | 効果 | 用途 |
|--------|------|------|
| `1.0` | 通常（フル可動） | 標準 |
| `0.5` | 感度半分 | 繊細な操作が必要な場合 |
| `-1.0` | 左右反転 | 配線や好みに応じて |
| `-0.5` | 感度半分 + 反転 | 組み合わせ |

#### スロットル（`JOYSTICK_MAX_THROTTLE`）

| 設定値 | 効果 | 用途 |
|--------|------|------|
| `1.0` | フルスロットル | 最高速度で走行 |
| `0.5` | **50%制限（推奨）** | 安全な走行、データ収集 |
| `0.3` | 30%制限 | 初心者・テスト用 |
| `0.8` | 80%制限 | 本番走行 |

#### スロットル方向（`JOYSTICK_THROTTLE_DIR`）

| 設定値 | 効果 |
|--------|------|
| `-1.0` | 通常（スティック上が前進） |
| `1.0` | 反転（スティック下が前進） |

### 動的調整（ボタンによる変更）

XboxOneJoystickController では、ボタンで `throttle_scale` を動的に変更できる：

```python
# controller.py より
def increase_max_throttle(self):
    self.throttle_scale = round(min(1.0, self.throttle_scale + 0.01), 2)

def decrease_max_throttle(self):
    self.throttle_scale = round(max(0.0, self.throttle_scale - 0.01), 2)
```

ボタンマッピング例（Xbox）：
- **RB（右肩ボタン）**: スロットル上限を+0.01
- **LB（左肩ボタン）**: スロットル上限を-0.01

### 推奨設定（用途別）

#### 初心者・テスト用
```python
JOYSTICK_MAX_THROTTLE = 0.3       # 低速で安全
JOYSTICK_STEERING_SCALE = 0.7     # 穏やかなステアリング
```

#### データ収集用
```python
JOYSTICK_MAX_THROTTLE = 0.5       # 一定速度で安定したデータ
JOYSTICK_STEERING_SCALE = 1.0     # フル可動
```

#### 本番レース用
```python
JOYSTICK_MAX_THROTTLE = 0.8       # 高速走行
JOYSTICK_STEERING_SCALE = 1.0     # 素早い反応
```

### 設定確認コマンド

```bash
# Raspberry Pi で実行
cd ~/mycar
python3 -c "
import donkeycar as dk
cfg = dk.load_config()
print('=== ジョイスティック感度設定 ===')
print('JOYSTICK_STEERING_SCALE:', cfg.JOYSTICK_STEERING_SCALE)
print('JOYSTICK_MAX_THROTTLE:', cfg.JOYSTICK_MAX_THROTTLE)
print('JOYSTICK_THROTTLE_DIR:', cfg.JOYSTICK_THROTTLE_DIR)
print('JOYSTICK_DEADZONE:', cfg.JOYSTICK_DEADZONE)
"
```

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026-01-29 21:00 | 初版作成 |
| 2026-01-29 21:30 | 軸コードの違いについて（技術解説）セクション追加 |
| 2026-01-29 21:45 | jstest実機テスト結果追加、解決策優先順位を更新（rc3推奨） |
| 2026-01-29 22:30 | ESP32-BLE-Gamepad ファームウェア変更による解決策調査セクション追加 |
| 2026-01-29 23:40 | ステアリング軸の反転設定（JOYSTICK_STEERING_SCALE = -1.0）セクション追加 |
| 2026-01-29 23:50 | ジョイスティック感度・速度調整セクション追加（JOYSTICK_MAX_THROTTLE等） |
