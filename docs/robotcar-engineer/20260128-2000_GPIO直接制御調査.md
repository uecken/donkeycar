# GPIO直接制御調査レポート

**作成日**: 2026年1月28日
**担当**: robotcar-engineer
**対象**: picopico_racersプロジェクト

---

## 目次

1. [Raspberry Pi GPIOからの直接サーボ制御](#1-raspberry-pi-gpioからの直接サーボ制御)
2. [HブリッジによるDCモーター制御](#2-hブリッジによるdcモーター制御)
3. [Donkey Carでの対応状況](#3-donkey-carでの対応状況)
4. [PCA9685との比較](#4-pca9685との比較)
5. [推奨構成](#5-推奨構成)
6. [モータードライバーの安全性](#6-モータードライバーの安全性)

---

## 1. Raspberry Pi GPIOからの直接サーボ制御

### 1.1 結論

**Raspberry PiのGPIOピンから直接サーボを制御することは可能**である。ただし、ハードウェアPWMとソフトウェアPWMの違いを理解し、適切なライブラリを選択する必要がある。

### 1.2 ハードウェアPWMとソフトウェアPWMの違い

| 項目 | ハードウェアPWM | ソフトウェアPWM |
|------|----------------|----------------|
| **生成方法** | BCM2835/2711チップ内蔵のPWMペリフェラル | CPUによるタイミング制御 |
| **精度** | 非常に高い（マイクロ秒レベル） | 中程度（ジッターが発生しやすい） |
| **CPU負荷** | ほぼゼロ | 軽度〜中程度 |
| **使用可能ピン数** | 4ピン（2チャンネル×2） | 全GPIOピン |
| **タイミング安定性** | OSの割り込みに影響されない | OSの割り込みで乱れる可能性あり |

### 1.3 ハードウェアPWM対応ピン

Raspberry Pi 4のハードウェアPWM対応ピンは以下の4つ:

| GPIOピン (BCM) | 物理ピン番号 | PWMチャンネル | 備考 |
|---------------|-------------|--------------|------|
| GPIO 12 | 32 | PWM0 | オーディオと共用 |
| GPIO 13 | 33 | PWM1 | オーディオと共用 |
| GPIO 18 | 12 | PWM0 | GPIO 12と同じチャンネル |
| GPIO 19 | 35 | PWM1 | GPIO 13と同じチャンネル |

> **重要: ハードウェアPWMは2チャンネルしかない**
>
> - PWM0チャンネル（GPIO 12, 18）は**同じ信号**を出力
> - PWM1チャンネル（GPIO 13, 19）は**同じ信号**を出力
> - つまり、**独立して制御できるのは2系統のみ**
>
> **これは重大な制約です**:
> - GPIO 12とGPIO 18に異なるPWM信号を出力することは**不可能**
> - GPIO 13とGPIO 19に異なるPWM信号を出力することは**不可能**
> - 3つ以上の独立したPWM信号が必要な場合は、ソフトウェアPWMまたはPCA9685を使用する必要があります

### 1.4 pigpioライブラリでのPWM制御方法

#### インストールと設定

```bash
# pigpioのインストール
sudo apt update && sudo apt install pigpio python3-pigpio

# pigpiodデーモンの起動
sudo systemctl start pigpiod
sudo systemctl enable pigpiod  # 自動起動設定
```

#### ハードウェアPWM制御（高精度）

```python
import pigpio

# pigpioデーモンに接続
pi = pigpio.pi()

# ハードウェアPWM設定
# hardware_PWM(gpio, frequency, dutycycle)
# dutycycleは0〜1,000,000（100万分率）

# サーボ制御: 50Hz、1500μs（ニュートラル）
# 1500μs = 1.5ms、周期20ms（50Hz）
# デューティサイクル = 1500 / 20000 * 1000000 = 75000
gpio_pin = 18  # または 12, 13, 19
pi.hardware_PWM(gpio_pin, 50, 75000)  # 50Hz, 7.5%デューティ

# パルス幅でサーボ位置を制御
def set_servo_pulse(pi, pin, pulse_us):
    """
    サーボにパルス幅を設定
    pulse_us: パルス幅（マイクロ秒）、通常1000〜2000
    """
    duty = int(pulse_us * 50)  # 50Hzの場合
    pi.hardware_PWM(pin, 50, duty)

# 例: 左端（1000μs）、中央（1500μs）、右端（2000μs）
set_servo_pulse(pi, 18, 1000)  # 左端
set_servo_pulse(pi, 18, 1500)  # 中央
set_servo_pulse(pi, 18, 2000)  # 右端

pi.stop()
```

#### ソフトウェアPWM制御（任意のピン）

```python
import pigpio

pi = pigpio.pi()

# ソフトウェアPWM（任意のGPIOピンで使用可能）
gpio_pin = 17  # 任意のGPIOピン

# set_servo_pulsewidth(gpio, pulsewidth)
# pulsewidthはマイクロ秒単位（0, 500-2500）
pi.set_servo_pulsewidth(gpio_pin, 1500)  # 中央位置

# サーボ制御関数
def control_servo(pi, pin, angle):
    """
    角度（-1〜1）をパルス幅に変換
    -1 = 1000μs, 0 = 1500μs, 1 = 2000μs
    """
    pulse = 1500 + (angle * 500)
    pi.set_servo_pulsewidth(pin, pulse)

pi.stop()
```

### 1.5 サーボ制御の精度要件

標準的なRCサーボの要件:

| パラメータ | 要件値 | pigpio達成可能性 |
|-----------|-------|-----------------|
| PWM周波数 | 50Hz（20ms周期） | 達成可能 |
| パルス幅範囲 | 1000〜2000μs | 達成可能 |
| パルス幅分解能 | 1μs以下推奨 | ハードウェアPWM: 達成可能 |
| ジッター | 10μs以下推奨 | ハードウェアPWM: 達成可能 |

**結論**: pigpioのハードウェアPWMを使用すれば、サーボ制御に必要な精度（50Hz、1000-2000μs）は十分に達成できる。

### 1.6 ハードウェアPWMの精度詳細

#### 1.6.1 Raspberry Pi 4のPWMクロック

| 項目 | Raspberry Pi 4 (BCM2711) | Raspberry Pi 3以前 (BCM2835) |
|------|--------------------------|------------------------------|
| **基準クロック** | **54 MHz** | 19.2 MHz |
| **クロック分周器** | 12bit整数部 + 12bitフラクショナル部 | 同左 |
| **最大分周値** | 4095 | 4095 |

> **重要**: Raspberry Pi 4は54MHzの水晶発振器を使用しており、Pi 3以前の19.2MHzより高い分解能が得られます。

#### 1.6.2 pigpioの`hardware_PWM()`精度

```python
# hardware_PWM(gpio, frequency, dutycycle)
# dutycycle: 0〜1,000,000（100万分率 = 0.0001%刻み）
pi.hardware_PWM(18, 50, 75000)  # 50Hz, 7.5%デューティ
```

| パラメータ | 範囲 | 説明 |
|-----------|------|------|
| **周波数** | 0〜125,000,000 Hz | Pi 4では0〜187,500,000 Hz |
| **デューティサイクル** | 0〜1,000,000 | 100万分率（0.0001%刻み） |
| **実用上限周波数** | 30 MHz以下 | それ以上は動作不安定 |

**50Hz（サーボ制御）での分解能計算**:

```
周期 = 1 / 50Hz = 20,000 μs（20ms）
デューティサイクル分解能 = 1,000,000段階
1段階あたりの時間 = 20,000 μs / 1,000,000 = 0.02 μs = 20 ns
```

| 項目 | 値 | 説明 |
|------|-----|------|
| **理論上の分解能** | 20 ns | 100万段階 × 20ms周期 |
| **実効分解能** | 約1 μs | DMAサンプリングレートによる制限 |
| **パルス幅1000〜2000μsの段階数** | 50,000段階 | (2000-1000) × 50 = 50,000 |

#### 1.6.3 pigpioの`set_servo_pulsewidth()`精度

```python
# set_servo_pulsewidth(gpio, pulsewidth)
# pulsewidth: 0（オフ）、500〜2500 μs
pi.set_servo_pulsewidth(17, 1500)  # 1500μs = ニュートラル
```

| 項目 | 値 | 説明 |
|------|-----|------|
| **入力単位** | マイクロ秒（整数） | 1μs刻みで指定 |
| **パルス幅範囲** | 500〜2500 μs | 0でオフ |
| **タイミング精度** | 数μs以内 | DMAによる正確なタイミング |
| **サンプリングレート** | 1, 2, 4, 5, 8, 10 μs | デフォルト5μs |

**DMA（Direct Memory Access）による高精度タイミング**:
- pigpioはDMAを使用してPWMパルスを生成
- OSのスケジューラ遅延（最大400μs）の影響を受けない
- 数マイクロ秒の精度でGPIO状態変化を制御可能

#### 1.6.4 PCA9685との精度比較

| 項目 | PCA9685 | pigpio hardware_PWM | pigpio set_servo_pulsewidth |
|------|---------|--------------------|-----------------------------|
| **分解能** | 12bit（4096段階） | 実質100万段階 | 1μs刻み |
| **50Hz時のパルス幅分解能** | 20,000 / 4096 = **4.88 μs** | **0.02 μs**（理論値） | **1 μs** |
| **1000〜2000μs範囲の段階数** | 約205段階 | 50,000段階 | 1,000段階 |
| **ジッター** | 低（専用ハードウェア） | 低（DMA制御） | 低（DMA制御） |
| **CPU負荷** | なし（I2C通信のみ） | なし | なし |

**結論**: pigpioのハードウェアPWMはPCA9685（12bit）より高い分解能を持ちます。

- **PCA9685**: 50Hz時、約4.88μsの分解能（サーボ制御には十分）
- **pigpio hardware_PWM**: 理論上0.02μsの分解能（実用上は1μs程度）
- **pigpio set_servo_pulsewidth**: 1μs刻みで指定可能

#### 1.6.5 ソフトウェアPWMとハードウェアPWMのジッター比較

| 項目 | ハードウェアPWM (pigpio) | ソフトウェアPWM (RPi.GPIO) |
|------|------------------------|---------------------------|
| **タイミング制御** | DMA（ハードウェア） | CPU（ソフトウェア） |
| **OSの影響** | 受けない | スケジューラ遅延の影響大 |
| **ジッター** | 数μs以内 | 数十〜数百μs |
| **サーボの動作** | スムーズ、安定 | 震え（ジッター）が発生 |

**ソフトウェアPWMでジッターが発生する理由**:
1. LinuxはリアルタイムOSではなく、スケジューラ遅延が最大400μsに達する
2. 他のプロセスがCPUを使用すると、PWMタイミングがずれる
3. サーボモーターは微小なパルス幅の変動を機械的な動きとして出力してしまう

**pigpioがジッターを低減する仕組み**:
1. DMA（Direct Memory Access）を使用してGPIOを制御
2. CPUを介さずにメモリから直接GPIOレジスタに書き込み
3. OSのスケジューリングとは独立して動作

#### 1.6.6 サーボ制御での実用的な精度

標準的なRCサーボの特性:

| パラメータ | 一般的な値 | 説明 |
|-----------|-----------|------|
| **デッドバンド** | 4〜8 μs | この範囲内のパルス変化は無視される |
| **1度あたりのパルス変化** | 約10 μs | 180度サーボの場合 |
| **実用的な精度要件** | 10 μs以下 | デッドバンドを考慮 |

**結論**: pigpioの1μs分解能は、サーボのデッドバンド（4〜8μs）より細かいため、サーボの機械的限界を超える精度を提供します。

### 1.7 PCA9685を使わない場合のメリット・デメリット

#### メリット

| 項目 | 説明 |
|------|------|
| **コスト削減** | PCA9685モジュール（約500〜1000円）が不要 |
| **配線の簡素化** | I2Cバスの配線が不要、直接接続のみ |
| **レイテンシー削減** | I2C通信のオーバーヘッドがない |
| **部品点数削減** | モジュール故障のリスク排除 |
| **デバッグ容易** | 直接的な信号確認が可能 |

#### デメリット

| 項目 | 説明 |
|------|------|
| **チャンネル数制限** | ハードウェアPWMは2系統のみ（サーボ+ESCでギリギリ） |
| **ピン競合** | GPIO 18はI2Sオーディオと共用 |
| **ソフトウェアPWMのジッター** | 3つ目以降のPWMはソフトウェア実装でジッターが発生 |
| **CPU負荷** | ソフトウェアPWM使用時はCPU負荷増加 |
| **電源供給** | サーボへの5V電源を別途用意する必要がある |

---

## 2. HブリッジによるDCモーター制御

### 2.1 概要

ブラシDCモーター + HブリッジICの構成は、ESC（ブラシレスモーター用）の代替として有効。特に低コスト・小型の車両に適している。

### 2.2 主要なHブリッジIC比較

| 項目 | L298N | TB6612FNG | L9110S |
|------|-------|-----------|--------|
| **動作電圧（モーター）** | 5〜46V | 4.5〜13.5V | 2.5〜12V |
| **ロジック電圧** | 5V | 2.7〜5.5V | 2.5〜12V |
| **連続電流（1ch）** | 2A | 1.2A | 0.8A |
| **ピーク電流** | 3A | 3.2A | 1.5A |
| **効率** | 40〜70% | >90% | 約85% |
| **放熱** | ヒートシンク必要 | 不要 | 不要 |
| **サイズ** | 大 | 小 | 極小 |
| **価格** | 約300円 | 約400円 | 約200円 |

**推奨**: **TB6612FNG**
- 3.3Vロジック対応でRaspberry Piと直接接続可能
- 高効率でバッテリー駆動に最適
- ヒートシンク不要でコンパクト

### 2.3 必要なGPIOピン数

#### 2ピンモード（L298N_HBridge_2pin）

各モーターに2本のPWMピン:
- **正転用PWMピン**: 正転時のデューティサイクル
- **逆転用PWMピン**: 逆転時のデューティサイクル

```
1モーター: 2ピン
2モーター（左右輪）: 4ピン
```

#### 3ピンモード（L298N_HBridge_3pin）

各モーターに3本のピン:
- **正転方向ピン (IN1)**: TTL出力
- **逆転方向ピン (IN2)**: TTL出力
- **速度制御PWMピン (ENA)**: PWM出力

```
1モーター: 3ピン（うち1本がPWM）
2モーター（左右輪）: 6ピン（うち2本がPWM）
```

### 2.4 PWMによる速度制御

```python
import pigpio

pi = pigpio.pi()

# TB6612FNG接続例
# 左モーター
LEFT_IN1 = 17   # GPIO17 - 正転
LEFT_IN2 = 27   # GPIO27 - 逆転
LEFT_PWM = 18   # GPIO18 - 速度（ハードウェアPWM）

# 右モーター
RIGHT_IN1 = 22  # GPIO22 - 正転
RIGHT_IN2 = 23  # GPIO23 - 逆転
RIGHT_PWM = 13  # GPIO13 - 速度（ハードウェアPWM）

# ピン設定
for pin in [LEFT_IN1, LEFT_IN2, RIGHT_IN1, RIGHT_IN2]:
    pi.set_mode(pin, pigpio.OUTPUT)

class DCMotor:
    def __init__(self, pi, in1, in2, pwm, frequency=1000):
        self.pi = pi
        self.in1 = in1
        self.in2 = in2
        self.pwm = pwm
        self.frequency = frequency

    def forward(self, speed):
        """正転: speed 0.0〜1.0"""
        self.pi.write(self.in1, 1)
        self.pi.write(self.in2, 0)
        duty = int(speed * 1000000)  # 0〜1000000
        self.pi.hardware_PWM(self.pwm, self.frequency, duty)

    def backward(self, speed):
        """逆転: speed 0.0〜1.0"""
        self.pi.write(self.in1, 0)
        self.pi.write(self.in2, 1)
        duty = int(speed * 1000000)
        self.pi.hardware_PWM(self.pwm, self.frequency, duty)

    def brake(self):
        """ブレーキ: 両方HIGHでショートブレーキ"""
        self.pi.write(self.in1, 1)
        self.pi.write(self.in2, 1)
        self.pi.hardware_PWM(self.pwm, self.frequency, 0)

    def coast(self):
        """コースト: 両方LOWでフリー回転"""
        self.pi.write(self.in1, 0)
        self.pi.write(self.in2, 0)
        self.pi.hardware_PWM(self.pwm, self.frequency, 0)

    def run(self, throttle):
        """
        スロットル制御: -1.0〜1.0
        負の値で逆転、正の値で正転
        """
        if throttle > 0:
            self.forward(throttle)
        elif throttle < 0:
            self.backward(-throttle)
        else:
            self.coast()

# 使用例
left_motor = DCMotor(pi, LEFT_IN1, LEFT_IN2, LEFT_PWM)
right_motor = DCMotor(pi, RIGHT_IN1, RIGHT_IN2, RIGHT_PWM)

left_motor.run(0.5)   # 左モーター 50%正転
right_motor.run(-0.3) # 右モーター 30%逆転
```

### 2.5 正転・逆転・ブレーキの制御方法

| 動作 | IN1 | IN2 | PWM | 説明 |
|------|-----|-----|-----|------|
| **正転** | HIGH | LOW | 0〜100% | モーター正方向回転 |
| **逆転** | LOW | HIGH | 0〜100% | モーター逆方向回転 |
| **ショートブレーキ** | HIGH | HIGH | - | 急速停止（能動的） |
| **コースト（フリー）** | LOW | LOW | - | 惰性走行 |
| **スタンバイ** | - | - | LOW | 省電力モード |

---

## 3. Donkey Carでの対応状況

### 3.1 サポート状況

Donkey Carフレームワークは、GPIO直接制御を**完全にサポート**している。

#### 関連パーツファイル

| ファイル | 説明 |
|----------|------|
| `donkeycar/parts/pins.py` | GPIO抽象化レイヤー（RPI_GPIO, PIGPIO, PCA9685対応） |
| `donkeycar/parts/actuator.py` | アクチュエーター制御クラス |

### 3.2 対応するドライブトレインタイプ

以下のドライブトレインタイプがGPIO直接制御をサポートしています:

| タイプ | 説明 | 使用クラス |
|--------|------|-----------|
| `PWM_STEERING_THROTTLE` | サーボ + ESC（標準RCカー） | `PulseController`, `PWMSteering`, `PWMThrottle` |
| `SERVO_HBRIDGE_2PIN` | サーボ + Hブリッジ（2ピンモード） | `PulseController`, `L298N_HBridge_2pin` |
| `SERVO_HBRIDGE_3PIN` | サーボ + Hブリッジ（3ピンモード） | `PulseController`, `L298N_HBridge_3pin` |
| `DC_TWO_WHEEL` | 差動2輪駆動（2ピンモード） | `L298N_HBridge_2pin`, `TwoWheelSteeringThrottle` |
| `DC_TWO_WHEEL_L298N` | 差動2輪駆動（3ピンモード） | `L298N_HBridge_3pin`, `TwoWheelSteeringThrottle` |

```python
# myconfig.py での設定例

# サーボ + ESC（標準RCカー構成）
DRIVE_TRAIN_TYPE = "PWM_STEERING_THROTTLE"
PWM_STEERING_THROTTLE = {
    "PWM_STEERING_PIN": "PIGPIO.BCM.18",      # GPIO18でサーボ制御
    "PWM_STEERING_SCALE": 1.0,
    "PWM_STEERING_INVERTED": False,
    "PWM_THROTTLE_PIN": "PIGPIO.BCM.13",      # GPIO13でESC制御
    "PWM_THROTTLE_SCALE": 1.0,
    "PWM_THROTTLE_INVERTED": False,
    "STEERING_LEFT_PWM": 460,
    "STEERING_RIGHT_PWM": 290,
    "THROTTLE_FORWARD_PWM": 500,
    "THROTTLE_STOPPED_PWM": 370,
    "THROTTLE_REVERSE_PWM": 240,
}

# サーボ + Hブリッジ（2ピンモード）
# ★★★ 注意: この設定はハードウェアPWMのみでは不可能 ★★★
# GPIO 13とGPIO 19は同じPWM1チャンネルを共有するため、
# 異なるPWM信号を出力できません。
# → SERVO_HBRIDGE_3PINを使用してください（下記参照）
#
# DRIVE_TRAIN_TYPE = "SERVO_HBRIDGE_2PIN"  # ← 使用不可
# SERVO_HBRIDGE_2PIN = {
#     "PWM_STEERING_PIN": "PIGPIO.BCM.18",
#     "FWD_DUTY_PIN": "PIGPIO.BCM.13",  # PWM1
#     "BWD_DUTY_PIN": "PIGPIO.BCM.19",  # PWM1 ← 同じチャンネル！
# }

# サーボ + Hブリッジ（3ピンモード）
DRIVE_TRAIN_TYPE = "SERVO_HBRIDGE_3PIN"
SERVO_HBRIDGE_3PIN = {
    "PWM_STEERING_PIN": "PIGPIO.BCM.18",      # サーボ制御
    "PWM_STEERING_SCALE": 1.0,
    "PWM_STEERING_INVERTED": False,
    "STEERING_LEFT_PWM": 460,
    "STEERING_RIGHT_PWM": 290,
    "FWD_PIN": "RPI_GPIO.BCM.17",             # 正転方向（TTL）
    "BWD_PIN": "RPI_GPIO.BCM.27",             # 逆転方向（TTL）
    "DUTY_PIN": "PIGPIO.BCM.13",              # 速度PWM
}

# 差動2輪駆動（2ピンモード）
DRIVE_TRAIN_TYPE = "DC_TWO_WHEEL"
DC_TWO_WHEEL = {
    "LEFT_FWD_DUTY_PIN": "PIGPIO.BCM.18",
    "LEFT_BWD_DUTY_PIN": "PIGPIO.BCM.12",
    "RIGHT_FWD_DUTY_PIN": "PIGPIO.BCM.13",
    "RIGHT_BWD_DUTY_PIN": "PIGPIO.BCM.19",
}

# 差動2輪駆動（3ピンモード、L298N用）
DRIVE_TRAIN_TYPE = "DC_TWO_WHEEL_L298N"
DC_TWO_WHEEL_L298N = {
    "LEFT_FWD_PIN": "RPI_GPIO.BCM.17",        # 左モーター正転方向（TTL）
    "LEFT_BWD_PIN": "RPI_GPIO.BCM.27",        # 左モーター逆転方向（TTL）
    "LEFT_EN_DUTY_PIN": "PIGPIO.BCM.18",      # 左モーター速度PWM
    "RIGHT_FWD_PIN": "RPI_GPIO.BCM.22",       # 右モーター正転方向（TTL）
    "RIGHT_BWD_PIN": "RPI_GPIO.BCM.23",       # 右モーター逆転方向（TTL）
    "RIGHT_EN_DUTY_PIN": "PIGPIO.BCM.13",     # 右モーター速度PWM
}
```

### 3.3 ピンID形式

Donkey Carでは以下の形式でピンを指定します（`pins.py`で実装）:

```
# RPI_GPIO（RPi.GPIOライブラリ使用）
"RPI_GPIO.BOARD.18"   # 物理ピン番号
"RPI_GPIO.BCM.24"     # BCM GPIO番号

# PIGPIO（pigpioライブラリ使用）
"PIGPIO.BCM.18"       # BCM GPIO番号のみ（BOARDは非対応）

# PCA9685（I2C経由）
"PCA9685.1:40.0"      # バス1、アドレス0x40、チャンネル0
```

**重要な注意点**:
1. **PIGPIOはBCMのみ対応**: PIGPIOを使用する場合、`PIGPIO.BCM.xx`形式のみがサポートされます。`PIGPIO.BOARD.xx`は使用できません（`pins.py`でエラーになります）。
2. **RPI_GPIOとPIGPIOの混在は非推奨**: 同一プログラム内での混在は技術的には可能ですが、予期しない動作の原因となる可能性があります。
3. **PCA9685のアドレス形式**: アドレスは16進数で指定（例: `40`は0x40）。

### 3.4 pins.pyの主要クラス

```python
# 入力ピン
InputPinGpio      # RPi.GPIO使用
InputPinPigpio    # pigpio使用

# 出力ピン（TTL）
OutputPinGpio     # RPi.GPIO使用
OutputPinPigpio   # pigpio使用
OutputPinPCA9685  # PCA9685使用

# PWMピン
PwmPinGpio        # RPi.GPIO使用（ソフトウェアPWM）
PwmPinPigpio      # pigpio使用（ハードウェア/ソフトウェアPWM）
PwmPinPCA9685     # PCA9685使用
```

---

## 4. PCA9685との比較

### 4.1 詳細比較表

| 項目 | PCA9685 | GPIO直接（PIGPIO） |
|------|---------|-------------------|
| **PWM精度** | 12bit（4096段階） | 実質10〜12bit相当 |
| **チャンネル数** | 16ch | ハードウェアPWM: 2ch、ソフトウェア: 多数 |
| **CPU負荷** | ほぼゼロ（I2C通信のみ） | ハードウェアPWM: ゼロ、ソフトウェアPWM: 軽度 |
| **配線の複雑さ** | I2C（SDA, SCL）+ 電源 | 各ピン個別配線 |
| **レイテンシー** | I2C通信分の遅延あり（約1ms） | 直接制御で最小 |
| **コスト** | +500〜1000円 | 追加コストなし |
| **拡張性** | 最大62デバイス（992ch）チェーン可能 | GPIOピン数で制限 |
| **PWM周波数** | 24Hz〜1526Hz（固定） | 任意に設定可能 |
| **ジッター** | 低（専用ハードウェア） | ハードウェアPWM: 低、ソフトウェア: 中 |
| **信頼性** | モジュール故障リスクあり | シンプルで故障点少ない |
| **デバッグ** | オシロスコープ必要 | 直接信号確認可能 |

### 4.2 使用ケース別推奨

| ケース | 推奨 | 理由 |
|--------|------|------|
| **2ch以下（サーボ+ESC）** | GPIO直接 | シンプル・低コスト |
| **3ch以上** | PCA9685 | チャンネル数確保 |
| **低レイテンシー重視** | GPIO直接 | I2C遅延なし |
| **拡張性重視** | PCA9685 | チェーン接続可能 |
| **バッテリー駆動** | GPIO直接 | 省電力 |
| **LED制御も必要** | PCA9685 | チャンネル余剰活用 |

---

## 5. 推奨構成

### 5.1 picopico_racersプロジェクト向け推奨

**重要**: picopico_racers（HBX 2192）は**1モーター + 1サーボ構成**です。

| コンポーネント | 数量 | 用途 |
|---------------|------|------|
| **RCモーター（ブラシモーター）** | 1つ | 前後移動（スロットル）用 |
| **サーボモーター** | 1つ | 左右ステアリング用 |

この構成は**差動2輪駆動（DC_TWO_WHEEL）ではありません**。

#### ハードウェアPWM 2チャンネル制限と実現可能な構成

| ドライブトレインタイプ | ハードウェアPWMのみで実現可能か | 説明 |
|----------------------|---------------------------|------|
| **PWM_STEERING_THROTTLE** | **可能** | サーボ（PWM0）+ ESC（PWM1）で2チャンネル使用 |
| **SERVO_HBRIDGE_3PIN** | **可能** | サーボ（PWM0）+ モーター速度（PWM1）+ 方向（GPIO） |
| **SERVO_HBRIDGE_2PIN** | **不可能** | 正転PWMと逆転PWMに異なる信号が必要（3チャンネル必要） |

> **警告**: `SERVO_HBRIDGE_2PIN`はハードウェアPWMのみでは実現できません。
> - FWD_DUTY_PIN（正転）とBWD_DUTY_PIN（逆転）に独立したPWM信号が必要
> - GPIO 13とGPIO 19は同じPWM1チャンネルを共有するため、異なる信号を出力できない
> - ソフトウェアPWMを使用する場合のみ可能（ただしジッターに注意）

**推奨ドライブトレインタイプ**:
1. **PWM_STEERING_THROTTLE + ESC**: 標準ESC使用（最も簡単）
2. **SERVO_HBRIDGE_3PIN + Hブリッジ**: 方向をGPIOで制御（低コスト）

**推奨構成: GPIO直接制御（PIGPIO）+ TB6612FNG（3ピンモード）**

#### 理由

1. **シンプルさ**: PCA9685が不要で配線・部品点数削減
2. **コスト**: モジュール費用削減（約500〜1000円）
3. **低レイテンシー**: I2C通信オーバーヘッドなし
4. **1モーター構成に最適**: HBX 2192は1モーター + 1サーボなので、TB6612FNGの1チャンネルで十分
5. **3.3Vロジック互換**: TB6612FNGはRaspberry Piと直接接続可能
6. **高効率**: TB6612FNGは>90%効率でバッテリー寿命向上
7. **安全機能充実**: 過電流・短絡・過熱・低電圧保護が内蔵

### 5.2 推奨ハードウェア構成

#### 構成A: PWM_STEERING_THROTTLE + ESC（最も簡単）

```
Raspberry Pi 4
├── GPIO 18 (PWM0) ──→ サーボ信号
└── GPIO 13 (PWM1) ──→ ESC信号
                            │
                            └── 370モーター

※ 2チャンネルでOK
```

#### 構成B: SERVO_HBRIDGE_3PIN + TB6612FNG（低コスト、推奨）

```
Raspberry Pi 4
├── GPIO 18 (PWM0) ──→ サーボ信号
├── GPIO 13 (PWM1) ──→ TB6612FNG PWMA（モーター速度）
├── GPIO 17 (TTL)  ──→ TB6612FNG AIN1（正転方向）
└── GPIO 27 (TTL)  ──→ TB6612FNG AIN2（逆転方向）
                            │
                            └── 370モーター

※ 2チャンネル（PWM）+ 2ピン（GPIO）でOK
```

> **注意**: picopico_racers（HBX 2192）は1モーター構成のため、差動2輪駆動用の配線は不要です。

### 5.3 代替構成（3系統以上のPWMが必要な場合）

SERVO_HBRIDGE_2PINや差動2輪駆動で、各モーターに独立したPWM制御が必要な場合:

```
構成A: PIGPIOソフトウェアPWM使用（ジッター注意）
- GPIO 18: サーボ（ハードウェアPWM）
- GPIO 13: モーター正転（ハードウェアPWM）
- GPIO 12: モーター逆転（ソフトウェアPWM）← ジッターが発生する可能性あり

構成B: PCA9685使用（推奨）
- PCA9685チャンネル0: サーボ
- PCA9685チャンネル1: モーター正転PWM
- PCA9685チャンネル2: モーター逆転PWM
```

> **重要**: picopico_racers（HBX 2192）は1モーター + 1サーボ構成のため、
> SERVO_HBRIDGE_3PINを使用すれば、ハードウェアPWM 2チャンネルで十分対応可能です。
> 3系統以上のPWMが必要な構成は、このプロジェクトでは不要です。

### 5.4 myconfig.py設定例

#### 構成A: PWM_STEERING_THROTTLE + ESC（最も簡単）

```python
# picopico_racers向け: ESC使用構成
DRIVE_TRAIN_TYPE = "PWM_STEERING_THROTTLE"

PWM_STEERING_THROTTLE = {
    # ステアリングサーボ（GPIO18でハードウェアPWM0）
    "PWM_STEERING_PIN": "PIGPIO.BCM.18",
    "PWM_STEERING_SCALE": 1.0,
    "PWM_STEERING_INVERTED": False,
    "STEERING_LEFT_PWM": 460,       # キャリブレーション値（donkey calibrateで測定）
    "STEERING_RIGHT_PWM": 290,      # キャリブレーション値（donkey calibrateで測定）

    # スロットル（GPIO13でハードウェアPWM1）
    "PWM_THROTTLE_PIN": "PIGPIO.BCM.13",
    "PWM_THROTTLE_SCALE": 1.0,
    "PWM_THROTTLE_INVERTED": False,
    "THROTTLE_FORWARD_PWM": 500,    # キャリブレーション値
    "THROTTLE_STOPPED_PWM": 370,    # キャリブレーション値
    "THROTTLE_REVERSE_PWM": 240,    # キャリブレーション値
}
# → ハードウェアPWM 2チャンネルでOK
```

#### 構成B: SERVO_HBRIDGE_3PIN + TB6612FNG（推奨、低コスト）

```python
# picopico_racers向け推奨設定: TB6612FNG 3ピンモード
# 方向制御がTTLなのでPWMチャンネルを1つ節約できる
DRIVE_TRAIN_TYPE = "SERVO_HBRIDGE_3PIN"

SERVO_HBRIDGE_3PIN = {
    # ステアリングサーボ（GPIO18でハードウェアPWM0）
    "PWM_STEERING_PIN": "PIGPIO.BCM.18",
    "PWM_STEERING_SCALE": 1.0,
    "PWM_STEERING_INVERTED": False,
    "STEERING_LEFT_PWM": 460,       # キャリブレーション値（donkey calibrateで測定）
    "STEERING_RIGHT_PWM": 290,      # キャリブレーション値（donkey calibrateで測定）

    # スロットル（TB6612FNG 3ピンモード）
    "FWD_PIN": "RPI_GPIO.BCM.17",   # 正転方向（TTL出力）
    "BWD_PIN": "RPI_GPIO.BCM.27",   # 逆転方向（TTL出力）
    "DUTY_PIN": "PIGPIO.BCM.13",    # 速度PWM（ハードウェアPWM1）
}
# → ハードウェアPWM 2チャンネル + GPIO 2ピンでOK
```

> **この構成を推奨する理由**:
> - ハードウェアPWM 2チャンネル制限内で実現可能
> - ESC不要で低コスト（TB6612FNG: 約400円）
> - 正転・逆転・ブレーキの細かい制御が可能

#### 差動2輪駆動（3ピンモード）- picopico_racersでは不要

> **注意**: picopico_racers（HBX 2192）は1モーター + 1サーボ構成のため、
> 差動2輪駆動の設定は不要です。以下は参考情報です。

```python
# 差動2輪駆動用設定（picopico_racersには不要）
DRIVE_TRAIN_TYPE = "DC_TWO_WHEEL_L298N"

DC_TWO_WHEEL_L298N = {
    # 左モーター
    "LEFT_FWD_PIN": "RPI_GPIO.BCM.17",       # 正転方向（TTL）
    "LEFT_BWD_PIN": "RPI_GPIO.BCM.27",       # 逆転方向（TTL）
    "LEFT_EN_DUTY_PIN": "PIGPIO.BCM.18",     # 速度PWM（ハードウェアPWM0）

    # 右モーター
    "RIGHT_FWD_PIN": "RPI_GPIO.BCM.22",      # 正転方向（TTL）
    "RIGHT_BWD_PIN": "RPI_GPIO.BCM.23",      # 逆転方向（TTL）
    "RIGHT_EN_DUTY_PIN": "PIGPIO.BCM.13",    # 速度PWM（ハードウェアPWM1）
}
# → ハードウェアPWM 2チャンネル + GPIO 4ピンでOK
```

### 5.5 電源に関する注意事項

1. **サーボ電源**: サーボは5V電源が必要。Raspberry PiのGPIOピンからは供給しない（電流不足）
2. **モーター電源**: TB6612FNGのVM端子にモーター用電源（4.5〜13.5V）を接続
3. **共通GND**: Raspberry Pi、TB6612FNG、電源のGNDは必ず共通化
4. **ノイズ対策**: モーター端子に0.1μFセラミックコンデンサを並列接続推奨

---

## 6. モータードライバーの安全性

モータードライバーIC（L298N、TB6612FNG、DRV8835等）の安全性比較については、以下の専門資料を参照してください：

**詳細資料**: [20260128-2100_モータードライバーIC調査.md](./20260128-2100_モータードライバーIC調査.md)

### 6.1 要約: picopico_racers（HBX 2192）への推奨

**推奨: TB6612FNGまたはDRV8835を使用**

| IC | 価格 | 電圧範囲 | 2S LiPo対応 | 安全機能 | 推奨度 |
|----|------|----------|------------|----------|--------|
| **TB6612FNG** | 180円 | 2.5-13.5V | **○** | なし（外部対策必要） | ★★★★☆ |
| **DRV8835** | 550円 | 2-11V | **○** | なし（外部対策必要） | ★★★★☆ |
| **TC78H660FNG** | 110円 | 2.5-16V | **○** | OCP, TSD内蔵 | ★★★★★ |
| **L298N** | 300円 | 5-46V | **○** | なし（発熱大） | ★★☆☆☆ |

> **注意: 2S LiPoバッテリーの満充電電圧は8.4V**
> モータードライバーを選定する際は、2S LiPoの満充電電圧（8.4V）に対応できるか確認してください。
> - **TC78H653FTG（最大7.5V）は2S LiPo非対応** - TC78H660FNG（最大16V）と混同しないこと

**選定理由**:
1. **1モーター + 1サーボ構成**に最適
2. **370モーターの電流（〜1A）**に対応可能
3. **3.3Vロジック対応**でRaspberry Piと直接接続可能
4. **高効率（>90%）**でバッテリー寿命向上

---

## 参考資料

- [Raspberry Pi Forums: Using Raspberry PI 4B for controlling servo motor (pigpio library)](https://forums.raspberrypi.com/viewtopic.php?t=291625)
- [Hackster.io: TB6612FNG Motor Driver: Better Than the L298N?](https://www.hackster.io/news/tb6612fng-motor-driver-better-than-the-l298n-7499a7574e63)
- [DroneBot Workshop: TB6612FNG H-Bridge with Arduino](https://dronebotworkshop.com/tb6612fng-h-bridge/)
- [PyPI: rpi-hardware-pwm](https://pypi.org/project/rpi-hardware-pwm/)
- [pigpio library - Python Interface](https://abyz.me.uk/rpi/pigpio/python.html)
- [Raspberry Pi Forums: PWM input clock frequency for Pi4](https://forums.raspberrypi.com/viewtopic.php?t=251902)
- [Raspberry Pi Forums: Hardware PWM frequency on Pi 4](https://forums.raspberrypi.com/viewtopic.php?t=275199)
- [Raspberry Pi Servo Jitter - Ben's blog](https://ben.akrin.com/raspberry-pi-servo-jitter/)
- [gpiozero Documentation: Output Devices](https://gpiozero.readthedocs.io/en/stable/api_output.html)
- [Adafruit PCA9685 16-Channel Servo Driver Guide](https://cdn-learn.adafruit.com/downloads/pdf/16-channel-pwm-servo-driver.pdf)
- Donkey Car ソースコード: `donkeycar/parts/pins.py`, `donkeycar/parts/actuator.py`

---

## 関連資料

このレポートと関連する他の調査資料：

| 資料名 | 内容 | リンク |
|--------|------|--------|
| PWM動作調査レポート | PCA9685の問題点 | [20260128-1730_PWM動作調査レポート.md](./20260128-1730_PWM動作調査レポート.md) |
| HBX2192制御調査 | HBX 2192固有の情報と推奨構成 | [20260128-2010_HBX2192制御調査.md](./20260128-2010_HBX2192制御調査.md) |
| モータードライバーIC調査 | IC比較・選定・安全性 | [20260128-2100_モータードライバーIC調査.md](./20260128-2100_モータードライバーIC調査.md) |
| DRV8835配線ガイド | 具体的な実装手順 | [20260128-2130_DRV8835配線ガイド.md](./20260128-2130_DRV8835配線ガイド.md) |

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026年1月28日 | 初版作成 |
| 2026年1月28日 | ソースコード検証に基づく修正: SERVO_HBRIDGE_3PIN追加、ピンID形式の注意事項追記、設定例の修正 |
| 2026年1月28日 | HBX 2192が1モーター + 1サーボ構成であることを明記、L298N安全性セクション追加、TB6612FNG推奨の理由を拡充 |
| 2026年1月28日 | **重要な修正**: ハードウェアPWM 2チャンネル制限を強調。SERVO_HBRIDGE_2PINはハードウェアPWMのみでは不可能であることを明記 |
| 2026年1月28日 | 資料整理: 安全性比較を簡略化し、詳細はモータードライバーIC調査を参照。関連資料セクション追加 |
| 2026年1月28日 | 2S LiPoバッテリー電圧（満充電8.4V）に関する注意事項を追記 |
| 2026年1月28日 | セクション1.6「ハードウェアPWMの精度詳細」を追加: PWMクロック、pigpio精度、PCA9685比較、ジッター比較 |
