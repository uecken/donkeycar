# Donkey Car 制御周期分析レポート

**作成日**: 2026年2月3日 16:20
**担当**: robotcar-engineer / ml-engineer
**目的**: センサー・カメラ・モデル推論の制御周期を明確化し、データ収集時と推論時の違いを理解する

---

## 目次

1. [概要](#1-概要)
2. [ドライブループ（メインループ）](#2-ドライブループメインループ)
3. [カメラの制御周期](#3-カメラの制御周期)
4. [センサーの制御周期](#4-センサーの制御周期)
5. [PWM/アクチュエーターの周期](#5-pwmアクチュエーターの周期)
6. [モデル推論の周期](#6-モデル推論の周期)
7. [データ収集時 vs 推論時の違い](#7-データ収集時-vs-推論時の違い)
8. [カメラ・制御系の実践的な動作確認](#8-カメラ制御系の実践的な動作確認)
9. [センサー・制御周期のログ確認方法](#9-センサー制御周期のログ確認方法) **NEW**
10. [同期の重要性](#10-同期の重要性)
11. [パフォーマンスモニタリング](#11-パフォーマンスモニタリング)
12. [推奨設定](#12-推奨設定)
13. [まとめ](#13-まとめ)

---

## 1. 概要

Donkey Carのリアルタイム制御は **ドライブループ** を中心に構成されている。各パーツ（カメラ、センサー、モデル、アクチュエーター）は同期的または非同期的（スレッド）に動作する。

---

## 2. ドライブループ（メインループ）

### 2.1 基本設定

| 設定項目 | 値 | 周期 | 備考 |
|---------|-----|------|------|
| `DRIVE_LOOP_HZ` | 20 | 50ms | デフォルト値 |
| 実際の周期 | ≤20Hz | ≥50ms | パーツの処理時間により変動 |

### 2.2 ループ処理フロー

```
donkeycar/vehicle.py:151-168

while self.on:
    start_time = time.time()

    self.update_parts()  # 全パーツを順次更新

    sleep_time = 1.0 / rate_hz - (time.time() - start_time)
    if sleep_time > 0.0:
        time.sleep(sleep_time)  # 目標周期まで待機
    else:
        # ジッター警告: ループが遅延している
        logger.info('WARN::Vehicle: jitter violation...')
```

### 2.3 パーツ実行モード

| モード | 実行方法 | 特徴 |
|--------|---------|------|
| **同期** | `p.run(*inputs)` | ループ内で直接実行、ループをブロック |
| **非同期** | `p.run_threaded(*inputs)` | 別スレッドで`update()`が継続実行、最新値を取得 |

---

## 3. カメラの制御周期

### 3.1 PiCamera（Picamera2）

```python
# donkeycar/parts/camera.py:23-82

class PiCamera(BaseCamera):
    def __init__(self, ...):
        # FrameDurationLimitsで0.1-1ms制限（実際は遅い）
        self.camera.set_controls({"FrameDurationLimits": (100, 1000)})

    def update(self):  # 非同期スレッドで実行
        while self.on:
            self.run()  # 継続的にフレーム取得

    def run_threaded(self):  # ドライブループから呼ばれる
        return self.frame  # 最新フレームを返すのみ
```

| 項目 | 値 | 備考 |
|------|-----|------|
| 設定 | `CAMERA_FRAMERATE = DRIVE_LOOP_HZ` | 20fps |
| 実動作 | カメラ依存 | Pi Camera 3: 30-60fps可能 |
| ドライブループへの提供 | 最新フレーム | スレッドで継続取得 |

### 3.2 Webcam

```python
# donkeycar/parts/camera.py:85-170

class Webcam(BaseCamera):
    def __init__(self, ..., framerate=20, ...):
        self.framerate = framerate  # 明示的に設定
```

---

## 4. センサーの制御周期

### 4.1 IMU（MPU6050/MPU9250）

```python
# donkeycar/parts/imu.py:29

def __init__(self, ..., poll_delay=0.0166, ...):  # 約60Hz
    self.poll_delay = poll_delay

def update(self):  # 非同期スレッド
    while self.on:
        self.poll()
        time.sleep(self.poll_delay)  # 60Hzで継続ポーリング
```

| 項目 | 値 | 周期 |
|------|-----|------|
| `poll_delay` | 0.0166秒 | 約60Hz |
| MPU9250磁力計 | AK8963_MODE_C100HZ | 100Hz |
| ドライブループへの提供 | 最新値 | スレッドで継続取得 |

### 4.2 エンコーダー（GPIO/pigpio）

```python
# donkeycar/parts/encoder.py:129

def __init__(self, ..., poll_delay=0.0166, ...):  # 約60Hz
    self.poll_delay = poll_delay
```

| 項目 | 値 | 周期 |
|------|-----|------|
| `poll_delay` | 0.0166秒 | 約60Hz |
| 動作モード | 非同期（スレッド） | 継続的にカウント |

### 4.3 LiDAR（RPLidar A1M8）

```python
# donkeycar/parts/lidar.py:49-64

class RPLidar2:
    # 実測値: 7スキャン/秒、1846測定/秒
    def __init__(self, ..., batch_ms=50, ...):
        self.batch_ms = batch_ms  # run()でのバッチ時間
```

| 項目 | 値 | 備考 |
|------|-----|------|
| スキャンレート | 約7Hz | 1回転/スキャン |
| 測定レート | 約1846Hz | 個別距離測定 |
| `batch_ms` | 50ms | run()でのデータ収集時間 |

---

## 5. PWM/アクチュエーターの周期

### 5.1 PCA9685 PWMボード

```python
# donkeycar/parts/actuator.py:128-175

class PCA9685:
    def __init__(self, ..., frequency=60, ...):
        self.default_freq = 60  # デフォルト60Hz
        self.pwm.set_pwm_freq(frequency)
```

| 項目 | 設定値 | 備考 |
|------|--------|------|
| `STEERING_PWM_FREQ` | 50Hz | サーボ標準周波数 |
| `THROTTLE_PWM_FREQ` | 50Hz | ESC標準周波数 |
| デフォルト周波数 | 60Hz | 旧コードでの設定 |

### 5.2 PWM信号の更新タイミング

```
ドライブループ(20Hz) → PWM set_pulse() → PCA9685(50Hz)
                                              ↓
                                         物理サーボ/ESC
```

**重要**: ドライブループは20Hzでも、PWM信号自体は50Hzで連続出力される。ドライブループの更新が遅れても、前回のPWM値が維持される。

---

## 6. モデル推論の周期

### 6.1 推論タイミング

```python
# donkeycar/parts/keras.py:95-116

class KerasPilot(ABC):
    def run(self, img_arr, *other_arr):
        # ドライブループ内で同期実行
        norm_img_arr = normalize_image(img_arr)
        ...
        return self.inference_from_dict(input_dict)
```

**モデルは同期実行**のため、推論時間がドライブループをブロックする。

### 6.2 推論時間の目安

| プラットフォーム | モデル | 推論時間 | 実効周波数 |
|-----------------|--------|---------|-----------|
| Raspberry Pi 4 | TFLite (Float32) | 40-80ms | 12-25Hz |
| Raspberry Pi 4 | TFLite (INT8) + Coral TPU | 10-20ms | 50-100Hz |
| Raspberry Pi 4 | Keras (Full) | 100-200ms | 5-10Hz |
| Jetson Nano | TensorRT | 10-20ms | 50-100Hz |
| GTX 1660 Ti (学習用) | Keras | 5-10ms | 100-200Hz |

### 6.3 Int8量子化とハードウェアアクセラレーション

**重要**: Donkey CarのInt8量子化は **Coral TPU** 向けに設計されている。

```python
# donkeycar/parts/interpreter.py:31-56
def keras_to_tflite(model, out_filename, data_gen=None):
    converter = tf.lite.TFLiteConverter.from_keras_model(model)
    if data_gen is not None:
        # Int8量子化（Coral TPU用）
        converter.target_ops = [tf.lite.OpsSet.TFLITE_BUILTINS_INT8]
        converter.inference_input_type = tf.uint8
        converter.inference_output_type = tf.uint8
        logger.info("using data generator to create int optimized weights for Coral TPU")
```

| 構成 | 量子化 | 推論時間 | 備考 |
|-----|--------|---------|------|
| Raspberry Pi 4 単体 | Float32 | 40-80ms | **標準構成（推奨）** |
| Raspberry Pi 4 単体 | Int8 (CPU) | 35-70ms | 効果限定的（約10-15%改善） |
| Raspberry Pi 4 + Coral USB | Int8 | 10-20ms | **高速化推奨構成** |

**Raspberry Pi 4 単体でのInt8推論**:
- TFLite CPUランタイムはInt8モデルを実行可能
- ただし、`TfLite.expand_and_convert()`がFloat32に変換するため、現在の実装ではInt8モデルでも入力はFloat32で処理される
- Coral TPU（USB Accelerator）を追加することで、真のInt8高速推論が可能

**Coral TPU使用時の設定**:
```python
# myconfig.py
TFLITE_DELEGATE = 'coral'  # Coral TPU使用
```

### 6.4 推論がドライブループに与える影響

```
DRIVE_LOOP_HZ = 20Hz → 目標周期: 50ms

例: 推論時間40msの場合
  - カメラ取得: 2ms
  - コントローラー: 1ms
  - モデル推論: 40ms  ← ボトルネック
  - アクチュエーター: 1ms
  - Tub書き込み: 5ms
  --------------------------
  合計: 49ms → 20Hzぎりぎり維持可能

例: 推論時間80msの場合
  合計: 89ms → 約11Hz（ジッター警告発生）
```

---

## 7. データ収集時 vs 推論時の違い

### 7.1 処理フロー比較

#### データ収集モード（手動運転）

```
[20Hzループ]
  ├─ カメラ取得 (threaded → 即座)
  ├─ コントローラー入力読み取り
  ├─ モード判定: user
  ├─ （モデル推論なし）
  ├─ アクチュエーター出力
  └─ Tub書き込み (約5ms)
```

| 項目 | 処理時間 | 備考 |
|------|---------|------|
| カメラ | <1ms | スレッドから最新値取得 |
| コントローラー | 1-2ms | ジョイスティック値読み取り |
| アクチュエーター | <1ms | I2C書き込み |
| Tub書き込み | 3-10ms | ディスクI/O |
| **合計** | **10-15ms** | 余裕あり |

#### 推論モード（自動運転）

```
[20Hzループ]
  ├─ カメラ取得 (threaded → 即座)
  ├─ コントローラー入力読み取り
  ├─ モード判定: local_angle/pilot
  ├─ モデル推論 (20-80ms) ← 追加処理
  ├─ アクチュエーター出力
  └─ Tub書き込み (オプション)
```

| 項目 | 処理時間 | 備考 |
|------|---------|------|
| カメラ | <1ms | スレッドから最新値取得 |
| コントローラー | 1-2ms | モード切替確認 |
| **モデル推論** | **20-80ms** | **ボトルネック** |
| アクチュエーター | <1ms | I2C書き込み |
| Tub書き込み | 3-10ms | オプション |
| **合計** | **25-95ms** | ジッターの可能性 |

### 7.2 タイミング図

```
データ収集モード (20Hz維持可能)
─────────────────────────────────────────────────────
|  Loop 1 (15ms)  |  sleep  |  Loop 2 (15ms)  | ...
─────────────────────────────────────────────────────
0ms              15ms      50ms             65ms

推論モード (TFLite INT8, 40ms推論)
─────────────────────────────────────────────────────
|    Loop 1 (50ms)    |    Loop 2 (50ms)    | ...
─────────────────────────────────────────────────────
0ms                  50ms                  100ms
           ↑ 20Hz維持

推論モード (TFLite Float32, 80ms推論)
─────────────────────────────────────────────────────
|      Loop 1 (90ms)      |      Loop 2 (90ms)      |
─────────────────────────────────────────────────────
0ms                      90ms                     180ms
           ↑ 約11Hzに低下（ジッター警告）
```

---

## 9. センサー・制御周期のログ確認方法

ドライブループやセンサーの動作周期を確認するためのログ設定と確認方法を解説する。

### 9.1 myconfig.pyに追加する設定

```python
# ===== 周期ログ確認用設定 =====
SHOW_FPS = True              # FPSカウンター有効化
FPS_DEBUG_INTERVAL = 5       # 5秒ごとにFPS表示
HAVE_PERFMON = True          # CPU/メモリ/周波数モニター
LOGGING_LEVEL = 'DEBUG'      # 詳細ログ出力
HAVE_CONSOLE_LOGGING = True  # コンソールログ有効化
```

### 9.2 各パーツの周期設定（デフォルト値）

| 設定項目 | 値 | 周期 | 説明 |
|---------|-----|------|------|
| DRIVE_LOOP_HZ | 20 | 50ms | メインループ周期 |
| CAMERA_FRAMERATE | 20 | 50ms | カメラFPS |
| PCA9685 PWM周波数 | 60Hz | 16.7ms | サーボ/ESC制御周期 |

### 9.3 実行コマンド

```bash
ssh koito@192.168.50.3
cd ~/mycar
python manage.py drive
```

### 9.4 ログ出力例

#### FPSログ（5秒ごと）
```
FPS: 19.8 (target: 20.0)
FPS: 20.1 (target: 20.0)
```

#### PerfMonログ
```
CPU: 45% | Memory: 512MB | Temp: 55.0°C | Freq: 1500MHz
```

#### 終了時のPartProfilerレポート（パーツごとの実行時間表）
```
Part Profile Summary: (times in ms)
+-------------------+-------+------+------+-------+-------+-------+--------+
|       part        |  max  | min  | avg  |  50%  |  90%  |  99%  | 99.9%  |
+-------------------+-------+------+------+-------+-------+-------+--------+
|    PiCamera       |  2.50 | 0.10 | 0.50 | 0.45  | 0.80  | 1.50  |  2.00  |
| JoystickController|  1.20 | 0.08 | 0.15 | 0.12  | 0.25  | 0.80  |  1.00  |
|    TfLitePilot    | 45.00 |38.00 |41.50 |41.00  |43.00  |44.50  | 44.90  |
|    PWMThrottle    |  0.80 | 0.10 | 0.20 | 0.18  | 0.30  | 0.50  |  0.70  |
|    TubWriter      |  8.00 | 2.00 | 4.50 | 4.00  | 6.00  | 7.50  |  7.90  |
+-------------------+-------+------+------+-------+-------+-------+--------+
```

### 9.5 verbose=Trueでの詳細ログ

manage.pyまたはcomplete.pyで`V.start()`に`verbose=True`を追加すると、200ループごとにプロファイラーレポートが出力される。

```python
# manage.py または complete.py の修正箇所
V.start(rate_hz=cfg.DRIVE_LOOP_HZ, max_loop_count=cfg.MAX_LOOPS, verbose=True)
```

**出力例**:
```
Loop 200: Profile Report
+-------------------+-------+------+------+-------+
|       part        |  max  | min  | avg  |  50%  |
+-------------------+-------+------+------+-------+
|    PiCamera       |  1.80 | 0.08 | 0.42 | 0.40  |
|    TfLitePilot    | 42.50 |39.00 |40.80 |40.50  |
...
Loop 400: Profile Report
...
```

### 9.6 ログ解釈のポイント

#### 目標周期を超えるパーツの特定

目標周期（50ms = 20Hz）を超えるパーツがボトルネックになる。

| パーツ | 平均時間 | 評価 |
|--------|---------|------|
| < 10ms | 良好 | 問題なし |
| 10-30ms | 注意 | 最適化検討 |
| 30-50ms | 警告 | ボトルネックの可能性 |
| > 50ms | 危険 | 必ず最適化が必要 |

#### ジッター警告の意味と対処法

```
WARN::Vehicle: jitter violation in vehicle loop with 15ms
```

この警告は、ループが目標周期（50ms）を15ms超過して65msかかったことを意味する。

| 超過時間 | 実効周波数 | 対処法 |
|---------|-----------|--------|
| <5ms | 約19Hz | 許容範囲、対処不要 |
| 5-15ms | 約15-18Hz | モデル軽量化を検討 |
| >15ms | <15Hz | DRIVE_LOOP_HZを下げるか、モデルを大幅に軽量化 |

**対処の優先順位**:
1. 推論時間の削減（モデル軽量化、入力サイズ縮小）
2. TubWriterの非同期化
3. DRIVE_LOOP_HZの削減（10-15Hzへ）
4. Coral TPU等のハードウェアアクセラレーター追加

---

## 10. 同期の重要性

### 10.1 データ収集時の同期

```
Tubレコード構造:
{
    "cam/image_array": <画像>,      ← ループ開始時点のフレーム
    "user/angle": <操舵角>,         ← 同一ループ内の入力
    "user/throttle": <スロットル>,   ← 同一ループ内の入力
    "_timestamp_ms": <タイムスタンプ>
}
```

**注意点**:
- カメラはスレッドで継続取得しているため、ループ開始時の「最新」フレームが使用される
- コントローラー入力とのタイムラグは最大 `1/DRIVE_LOOP_HZ` (50ms)

### 10.2 推論時の同期

```
推論入力:
  - 画像: ループ開始時点の最新フレーム
  - IMU: ループ開始時点の最新値（使用時）

推論出力:
  - 角度/スロットル: 同一ループ内でアクチュエーターへ

レイテンシ:
  画像取得 → 推論完了 → PWM更新 = 推論時間 + 数ms
```

---

## 11. パフォーマンスモニタリング

### 11.1 プロファイラー

```python
# donkeycar/vehicle.py:20-58

class PartProfiler:
    def on_part_start(self, p):
        self.records[p]['times'].append(time.time())

    def on_part_finished(self, p):
        delta = now - prev
        self.records[p]['times'][-1] = delta

    def report(self):
        # 各パーツの max, min, avg, 50%, 90%, 99%, 99.9% を表示
```

### 11.2 プロファイルレポートの確認

```bash
python manage.py drive --verbose
# 200ループごとにプロファイルレポートが出力される
```

出力例:
```
Part Profile Summary: (times in ms)
+----------------+-------+------+-------+-------+-------+-------+--------+
|      part      |  max  | min  |  avg  |  50%  |  90%  |  99%  | 99.9%  |
+----------------+-------+------+-------+-------+-------+-------+--------+
|    PiCamera    |  2.50 | 0.10 |  0.50 |  0.45 |  0.80 |  1.50 |  2.00  |
| JoystickController | 1.20 | 0.08 | 0.15 | 0.12 | 0.25 | 0.80 | 1.00 |
|   KerasPilot   | 45.00 | 38.00| 41.50 | 41.00 | 43.00 | 44.50 | 44.90  |
|   PWMThrottle  |  0.80 | 0.10 |  0.20 |  0.18 |  0.30 |  0.50 |  0.70  |
|   TubWriter    |  8.00 | 2.00 |  4.50 |  4.00 |  6.00 |  7.50 |  7.90  |
+----------------+-------+------+-------+-------+-------+-------+--------+
```

---

## 12. 推奨設定

### 12.1 Raspberry Pi 4 向け推奨

| 項目 | 推奨値 | 理由 |
|------|--------|------|
| `DRIVE_LOOP_HZ` | 20 | 標準値 |
| `CAMERA_FRAMERATE` | 20 | ドライブループと同期 |
| モデル形式 | **TFLite Float32** | Raspberry Pi 4単体での標準構成 |
| IMU `poll_delay` | 0.0166 | 60Hz、十分な頻度 |

**量子化オプション**:
| 構成 | 推奨モデル形式 | 期待される推論周波数 |
|------|---------------|---------------------|
| Raspberry Pi 4 単体 | TFLite Float32 | 12-25Hz |
| Raspberry Pi 4 + Coral USB | TFLite Int8 | 50-100Hz |

### 12.2 推論性能を最優先する場合

| 項目 | 設定 | 備考 |
|------|------|------|
| `DRIVE_LOOP_HZ` | 10-15 | 推論時間に合わせて下げる |
| モデル入力サイズ | 120x160 | 小さいほど高速 |
| **ハードウェア追加** | Coral USB Accelerator | Int8高速推論に必須 |
| モデル量子化 | INT8 (Coral TPU使用時のみ) | Coral TPUで2-4倍高速 |

**注意**: Raspberry Pi 4 単体でのInt8量子化は、Coral TPU未使用時は効果が限定的（約10-15%改善のみ）。
Float32モデルの方が実装がシンプルで安定動作する。

---

## 13. まとめ

| 項目 | データ収集時 | 推論時 |
|------|-------------|--------|
| メインループ周波数 | 20Hz (維持容易) | 10-20Hz (モデル依存) |
| カメラ | 20Hz (同期) | 20Hz (スレッド) |
| IMU | 60Hz (スレッド) | 60Hz (スレッド) |
| PWM出力 | 50Hz (連続) | 50Hz (連続) |
| ボトルネック | Tub書き込み (5-10ms) | **モデル推論 (20-80ms)** |
| ジッター発生 | まれ | 推論時間>50msで頻発 |

### 重要な注意点

1. **データ収集と推論の画像同期**
   - データ収集時: 画像とユーザー入力は同一ループ内
   - 推論時: 画像から推論結果までのレイテンシが発生

2. **スレッドパーツの最新値**
   - カメラ、IMUはスレッドで継続更新
   - ドライブループは「最新値」を取得するのみ
   - 厳密な同期は保証されない

3. **PWMの独立性**
   - ドライブループが遅延しても、PWM信号は前回値を維持
   - アクチュエーターは安定動作

---

## 8. カメラ・制御系の実践的な動作確認

### 8.1 カメラFPSの確認方法

#### 8.1.1 PiCamera（Picamera2）のFPS確認

```python
#!/usr/bin/env python3
"""
PiCamera FPS計測スクリプト
usage: python camera_fps_test.py
"""
from picamera2 import Picamera2
import time

def test_picamera_fps(width=160, height=120, duration=10):
    """Picamera2の実際のFPSを計測"""
    camera = Picamera2()
    config = camera.create_preview_configuration(
        {"size": (width, height), "format": "BGR888"}
    )
    camera.configure(config)

    # FrameDurationLimitsで制限（Donkeycarのデフォルト設定）
    camera.set_controls({"FrameDurationLimits": (100, 1000)})
    camera.start()

    print(f"Testing camera {width}x{height} for {duration} seconds...")
    frame_count = 0
    start_time = time.time()

    while time.time() - start_time < duration:
        frame = camera.capture_array("main")
        frame_count += 1

    elapsed = time.time() - start_time
    fps = frame_count / elapsed

    print(f"\n=== Camera FPS Test Results ===")
    print(f"Resolution: {width}x{height}")
    print(f"Frames captured: {frame_count}")
    print(f"Time elapsed: {elapsed:.2f} seconds")
    print(f"Actual FPS: {fps:.2f}")
    print(f"Frame time: {1000/fps:.2f} ms")

    camera.stop()
    camera.close()
    return fps

if __name__ == "__main__":
    test_picamera_fps()
```

**SSH経由での実行**:
```bash
ssh koito@192.168.50.3
cd ~/mycar
python camera_fps_test.py
```

#### 8.1.2 カメラ設定の確認コマンド

```bash
# libcameraでカメラ情報確認
libcamera-hello --list-cameras

# カメラのサポート解像度・FPS確認
v4l2-ctl --list-formats-ext -d /dev/video0

# 現在のカメラ設定確認
vcgencmd get_camera
```

#### 8.1.3 FrameDurationLimitsの意味

```python
# donkeycar/parts/camera.py Line 41
self.camera.set_controls({"FrameDurationLimits": (100, 1000)})

# FrameDurationLimits: (min_us, max_us)
# - 100us = 0.1ms  → 理論最大: 10000 FPS
# - 1000us = 1ms   → 理論最大: 1000 FPS
# 実際はセンサーの限界（30-60 FPS）が適用される
```

| 設定値 | 意味 | Donkeycarでの効果 |
|-------|------|-------------------|
| min=100us | 最短フレーム間隔 | カメラ側で最速取得を許可 |
| max=1000us | 最長フレーム間隔 | 実質的に制限なし |

### 8.2 PWM/アクチュエーター周波数の確認方法

#### 8.2.1 PCA9685の周波数確認

```python
#!/usr/bin/env python3
"""
PCA9685 PWM周波数確認スクリプト
usage: python pwm_freq_test.py
"""
import time
import board
import busio
from adafruit_pca9685 import PCA9685

def check_pca9685():
    """PCA9685の現在設定を確認"""
    i2c = busio.I2C(board.SCL, board.SDA)
    pca = PCA9685(i2c, address=0x40)

    # 周波数設定（Donkeycarデフォルト: 60Hz）
    pca.frequency = 60

    print(f"=== PCA9685 Configuration ===")
    print(f"I2C Address: 0x40")
    print(f"PWM Frequency: {pca.frequency} Hz")
    print(f"PWM Period: {1000/pca.frequency:.2f} ms")

    return pca

def test_pwm_output(pca, channel=0, duty_percent=50, duration=5):
    """PWM出力テスト"""
    duty_cycle = int(65535 * duty_percent / 100)

    print(f"\nTesting Channel {channel} at {duty_percent}% duty cycle...")
    pca.channels[channel].duty_cycle = duty_cycle
    time.sleep(duration)
    pca.channels[channel].duty_cycle = 0
    print("Test complete")

if __name__ == "__main__":
    pca = check_pca9685()
    # test_pwm_output(pca, channel=0, duty_percent=50)
    pca.deinit()
```

#### 8.2.2 I2Cデバイス確認コマンド

```bash
# I2Cバスのデバイス検出
i2cdetect -y 1

# 期待される出力:
#      0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
# 00:          -- -- -- -- -- -- -- -- -- -- -- -- --
# 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
# 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
# 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
# 40: 40 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  ← PCA9685
# 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
# 60: -- -- -- -- -- -- -- -- 68 -- -- -- -- -- -- --  ← MPU6050（使用時）
# 70: -- -- -- -- -- -- -- --
```

#### 8.2.3 PWMパルス幅の計算

```
PCA9685 PWM信号仕様:
- 周波数: 60Hz（デフォルト）
- 周期: 16.67ms
- 分解能: 12bit (0-4095)

RCサーボ標準:
- 中立: 1.5ms パルス
- 最小: 1.0ms パルス
- 最大: 2.0ms パルス

12bit値への変換:
- パルス幅(ms) = (12bit値 / 4095) × 周期(ms)
- 例: 370 → (370/4095) × 16.67 = 1.51ms（ほぼ中立）

Donkeycarのデフォルト設定（config.py）:
- STEERING_LEFT_PWM = 460  → 約1.87ms
- STEERING_RIGHT_PWM = 290 → 約1.18ms
- THROTTLE_STOPPED_PWM = 370 → 約1.51ms
```

### 8.3 ドライブループ周波数のリアルタイム確認

#### 8.3.1 myconfig.pyでの設定

```python
# ~/mycar/myconfig.py

# 基本設定
DRIVE_LOOP_HZ = 20  # 目標: 20Hz（50ms/loop）

# FPS表示を有効化
SHOW_FPS = True
FPS_DEBUG_INTERVAL = 10  # 10秒ごとに表示

# パフォーマンスモニター有効化
HAVE_PERFMON = True

# ログ出力設定
HAVE_CONSOLE_LOGGING = True
LOGGING_LEVEL = 'INFO'
```

#### 8.3.2 verboseモードでの実行

```bash
# manage.py を修正して verbose=True を追加
# または一時的に以下のコードをmanage.pyに追加:

# V.start() の呼び出しを変更
V.start(rate_hz=cfg.DRIVE_LOOP_HZ, max_loop_count=cfg.MAX_LOOPS, verbose=True)

# 実行
cd ~/mycar
python manage.py drive
```

**出力例**:
```
Starting vehicle at 20 Hz
...
Part Profile Summary: (times in ms)
+-------------------+-------+------+------+-------+-------+-------+--------+
|       part        |  max  | min  | avg  |  50%  |  90%  |  99%  | 99.9%  |
+-------------------+-------+------+------+-------+-------+-------+--------+
|    PiCamera       |  2.50 | 0.10 | 0.50 | 0.45  | 0.80  | 1.50  |  2.00  |
| JoystickController|  1.20 | 0.08 | 0.15 | 0.12  | 0.25  | 0.80  |  1.00  |
|    TfLitePilot    | 45.00 |38.00 |41.50 |41.00  |43.00  |44.50  | 44.90  |
|    PWMThrottle    |  0.80 | 0.10 | 0.20 | 0.18  | 0.30  | 0.50  |  0.70  |
|    TubWriter      |  8.00 | 2.00 | 4.50 | 4.00  | 6.00  | 7.50  |  7.90  |
+-------------------+-------+------+------+-------+-------+-------+--------+
```

#### 8.3.3 ジッター警告の解釈

```
# ループが目標周期を超えた場合に表示される警告
WARN::Vehicle: jitter violation in vehicle loop with XXXXms

例: WARN::Vehicle: jitter violation in vehicle loop with 15ms
→ 目標50ms(20Hz)に対して65msかかった
→ 15ms超過 = 実効周波数が低下
```

| 超過時間 | 実効周波数 | 対処法 |
|---------|-----------|--------|
| <5ms | 約19Hz | 許容範囲 |
| 5-10ms | 約17-18Hz | 軽微な最適化推奨 |
| 10-20ms | 約14-16Hz | モデル軽量化が必要 |
| >30ms | <12Hz | DRIVE_LOOP_HZ削減を検討 |

### 8.4 SSH経由での一括確認手順

```bash
# 1. SSH接続
ssh koito@192.168.50.3

# 2. システム状態確認
echo "=== System Info ==="
cat /proc/cpuinfo | grep "model name" | head -1
cat /proc/meminfo | grep MemTotal
vcgencmd measure_temp

# 3. I2Cデバイス確認
echo "\n=== I2C Devices ==="
i2cdetect -y 1 2>/dev/null || echo "i2cdetect not available"

# 4. カメラ確認
echo "\n=== Camera Status ==="
vcgencmd get_camera
libcamera-hello --list-cameras 2>/dev/null || echo "libcamera not available"

# 5. Donkeycar起動テスト（5秒で終了）
echo "\n=== Donkeycar Quick Test ==="
cd ~/mycar
timeout 5 python manage.py drive 2>&1 | head -20

# 6. 起動後のプロファイル確認（推論モード）
# manage.py の MAX_LOOPS = 100 に設定して実行
python manage.py drive --model models/pilot.tflite
```

### 8.5 デバッグ用のログ設定

#### 8.5.1 DEBUGレベルでの詳細ログ

```python
# ~/mycar/myconfig.py
LOGGING_LEVEL = 'DEBUG'  # INFO → DEBUG に変更
```

#### 8.5.2 特定パーツのデバッグ

```python
# ~/mycar/manage.py または専用スクリプト
import logging

# 特定モジュールのログレベルを変更
logging.getLogger('donkeycar.parts.camera').setLevel(logging.DEBUG)
logging.getLogger('donkeycar.parts.actuator').setLevel(logging.DEBUG)
logging.getLogger('donkeycar.vehicle').setLevel(logging.DEBUG)
```

#### 8.5.3 タイムスタンプ付きログ

```python
# ~/mycar/myconfig.py
LOGGING_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
```

### 8.6 確認ポイントまとめ

| 項目 | 確認方法 | 目標値 |
|------|---------|--------|
| **カメラFPS** | `camera_fps_test.py` | ≥30 FPS |
| **PCA9685周波数** | I2C + 設定確認 | 60Hz |
| **ドライブループ** | `SHOW_FPS=True` | 20Hz |
| **推論時間** | `verbose=True` | <45ms |
| **I2Cデバイス** | `i2cdetect -y 1` | 0x40表示 |
| **カメラ状態** | `vcgencmd get_camera` | supported=1 detected=1 |

### 8.7 トラブルシューティング

| 症状 | 原因 | 対処法 |
|------|------|--------|
| FPSが低い（<15Hz） | 推論時間が長い | num_threads=4設定、モデル軽量化 |
| ジッター警告頻発 | ループ内処理が重い | PartProfilerで特定、最適化 |
| カメラ取得遅延 | USBカメラのバッファ | PiCamera推奨、バッファ設定調整 |
| PWM反応遅い | I2C通信遅延 | I2C速度確認（通常は問題なし） |
| 不安定な動作 | 電源不足 | 3A以上のACアダプター使用 |

---

## 関連資料

- [donkeycar/vehicle.py](../../donkeycar/vehicle.py) - ドライブループ実装
- [donkeycar/parts/camera.py](../../donkeycar/parts/camera.py) - カメラパーツ
- [donkeycar/parts/imu.py](../../donkeycar/parts/imu.py) - IMUパーツ
- [donkeycar/parts/keras.py](../../donkeycar/parts/keras.py) - モデル推論
- [donkeycar/parts/actuator.py](../../donkeycar/parts/actuator.py) - PWMアクチュエーター
- [donkeycar/parts/interpreter.py](../../donkeycar/parts/interpreter.py) - TFLite/TensorRT推論

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026-02-03 16:20 | 初版作成 |
| 2026-02-08 17:20 | Int8量子化とCoral TPU要件を明確化（ml-engineer調査結果反映） |
| 2026-02-13 18:00 | 「8. カメラ・制御系の実践的な動作確認」セクション追加（robotcar-engineer） |
| 2026-02-13 | 「9. センサー・制御周期のログ確認方法」セクション追加（robotcar-engineer） |
